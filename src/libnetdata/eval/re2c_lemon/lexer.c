/* Generated by re2c 4.1 on Wed Apr 16 20:13:00 2025 */
#line 1 "lexer.re"
/**
 * re2c lexer for Netdata's expression evaluator
 *
 * This implementation uses re2c for lexical analysis and lemon for parsing.
 * It is fully integrated with Netdata's existing EVAL_NODE structure.
 */

#include "../eval-internal.h"
#include "parser_internal.h"

// Scanner functions implementation
void scanner_init(Scanner *s, const char *input) {
    if (!input) {
        // Handle NULL input safely
        s->cursor = "";
        s->marker = s->cursor;
        s->token = s->cursor;
        s->limit = s->cursor;
        s->line = 1;
        s->error = 1;  // Set error flag for NULL input
        return;
    }
    
    s->cursor = input;
    s->marker = s->cursor;
    s->token = s->cursor;
    s->limit = s->cursor + strlen(s->cursor);
    s->line = 1;
    s->error = 0;  // Initialize error flag
}

int scan(Scanner *s, YYSTYPE *lval) {
    const char *YYMARKER;
    const char *YYCURSOR = s->cursor;
    char variable_buffer[EVAL_MAX_VARIABLE_NAME_LENGTH + 1] = {0};
    
    // Skip whitespace
    while (1) {
        s->token = YYCURSOR;
        

#line 45 "lexer.c"
{
	char yych;
	unsigned int yyaccept = 0;
	yych = *YYCURSOR;
	switch (yych) {
		case 0x00: goto yy1;
		case '\t':
		case '\n':
		case '\r':
		case ' ': goto yy4;
		case '!': goto yy6;
		case '$': goto yy8;
		case '%': goto yy9;
		case '&': goto yy10;
		case '(': goto yy11;
		case ')': goto yy12;
		case '*': goto yy13;
		case '+': goto yy14;
		case '-': goto yy15;
		case '.': goto yy16;
		case '/': goto yy17;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy18;
		case ':': goto yy20;
		case '<': goto yy21;
		case '=': goto yy23;
		case '>': goto yy25;
		case '?': goto yy27;
		case 'A': goto yy28;
		case 'N': goto yy29;
		case 'O': goto yy30;
		case 'a': goto yy31;
		case 'n': goto yy32;
		case 'o': goto yy33;
		case '|': goto yy34;
		default: goto yy2;
	}
yy1:
	++YYCURSOR;
#line 126 "lexer.re"
	{ s->cursor = YYCURSOR; return 0; }
#line 95 "lexer.c"
yy2:
	++YYCURSOR;
yy3:
#line 129 "lexer.re"
	{ 
        s->cursor = YYCURSOR; 
        s->error = 1;  // Set error flag
        return 0;      // Return 0 to stop parsing
    }
#line 105 "lexer.c"
yy4:
	yych = *++YYCURSOR;
	switch (yych) {
		case '\t':
		case '\n':
		case '\r':
		case ' ': goto yy4;
		default: goto yy5;
	}
yy5:
#line 46 "lexer.re"
	{ continue; }
#line 118 "lexer.c"
yy6:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy35;
		default: goto yy7;
	}
yy7:
#line 101 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_NOT; }
#line 128 "lexer.c"
yy8:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy36;
		case '{': goto yy38;
		default: goto yy3;
	}
yy9:
	++YYCURSOR;
#line 96 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_MODULO; }
#line 202 "lexer.c"
yy10:
	yych = *++YYCURSOR;
	switch (yych) {
		case '&': goto yy40;
		default: goto yy3;
	}
yy11:
	++YYCURSOR;
#line 116 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_LPAREN; }
#line 213 "lexer.c"
yy12:
	++YYCURSOR;
#line 117 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_RPAREN; }
#line 218 "lexer.c"
yy13:
	++YYCURSOR;
#line 94 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_MULTIPLY; }
#line 223 "lexer.c"
yy14:
	++YYCURSOR;
#line 92 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_PLUS; }
#line 228 "lexer.c"
yy15:
	++YYCURSOR;
#line 93 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_MINUS; }
#line 233 "lexer.c"
yy16:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy41;
		default: goto yy3;
	}
yy17:
	++YYCURSOR;
#line 95 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_DIVIDE; }
#line 253 "lexer.c"
yy18:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '.': goto yy41;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy18;
		case 'E':
		case 'e': goto yy42;
		default: goto yy19;
	}
yy19:
#line 54 "lexer.re"
	{
        char *endptr;
        lval->dval = str2ndd(s->token, &endptr);
        s->cursor = YYCURSOR;
        return TOK_NUMBER;
    }
#line 281 "lexer.c"
yy20:
	++YYCURSOR;
#line 113 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_COLON; }
#line 286 "lexer.c"
yy21:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy44;
		case '>': goto yy35;
		default: goto yy22;
	}
yy22:
#line 106 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_LT; }
#line 297 "lexer.c"
yy23:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy45;
		default: goto yy24;
	}
yy24:
#line 104 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_EQ; }
#line 307 "lexer.c"
yy25:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy46;
		default: goto yy26;
	}
yy26:
#line 108 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_GT; }
#line 317 "lexer.c"
yy27:
	++YYCURSOR;
#line 112 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_QMARK; }
#line 322 "lexer.c"
yy28:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'N': goto yy47;
		case 'n': goto yy48;
		default: goto yy3;
	}
yy29:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'O': goto yy49;
		case 'o': goto yy50;
		default: goto yy3;
	}
yy30:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'R':
		case 'r': goto yy51;
		default: goto yy3;
	}
yy31:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'b': goto yy52;
		case 'n': goto yy48;
		default: goto yy3;
	}
yy32:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'o': goto yy50;
		default: goto yy3;
	}
yy33:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'r': goto yy51;
		default: goto yy3;
	}
yy34:
	yych = *++YYCURSOR;
	switch (yych) {
		case '|': goto yy51;
		default: goto yy3;
	}
yy35:
	++YYCURSOR;
#line 105 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_NE; }
#line 377 "lexer.c"
yy36:
	yych = *++YYCURSOR;
	switch (yych) {
		case '.':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy36;
		default: goto yy37;
	}
yy37:
#line 62 "lexer.re"
	{
        size_t len = YYCURSOR - s->token - 1; // -1 to skip the $
        if (len >= EVAL_MAX_VARIABLE_NAME_LENGTH) {
            len = EVAL_MAX_VARIABLE_NAME_LENGTH - 1;
        }
        memcpy(variable_buffer, s->token + 1, len);
        variable_buffer[len] = '\0';
        lval->strval = strdupz(variable_buffer);
        s->cursor = YYCURSOR;
        return TOK_VARIABLE;
    }
#line 460 "lexer.c"
yy38:
	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 0x00: goto yy39;
		case '}': goto yy54;
		default: goto yy53;
	}
yy39:
#line 123 "lexer.re"
	{ s->cursor = YYCURSOR; s->error = 1; return 0; }
#line 472 "lexer.c"
yy40:
	++YYCURSOR;
#line 99 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_AND; }
#line 477 "lexer.c"
yy41:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy41;
		case 'E':
		case 'e': goto yy42;
		default: goto yy19;
	}
yy42:
	yych = *++YYCURSOR;
	switch (yych) {
		case '+':
		case '-': goto yy55;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy56;
		default: goto yy43;
	}
yy43:
	YYCURSOR = YYMARKER;
	switch (yyaccept) {
		case 0: goto yy19;
		case 1: goto yy3;
		default: goto yy39;
	}
yy44:
	++YYCURSOR;
#line 107 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_LE; }
#line 524 "lexer.c"
yy45:
	++YYCURSOR;
	goto yy24;
yy46:
	++YYCURSOR;
#line 109 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_GE; }
#line 532 "lexer.c"
yy47:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'D': goto yy40;
		default: goto yy43;
	}
yy48:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'd': goto yy40;
		default: goto yy43;
	}
yy49:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'T': goto yy57;
		default: goto yy43;
	}
yy50:
	yych = *++YYCURSOR;
	switch (yych) {
		case 't': goto yy57;
		default: goto yy43;
	}
yy51:
	++YYCURSOR;
#line 100 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_OR; }
#line 561 "lexer.c"
yy52:
	yych = *++YYCURSOR;
	switch (yych) {
		case 's': goto yy58;
		default: goto yy43;
	}
yy53:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy43;
		case '}': goto yy59;
		default: goto yy53;
	}
yy54:
	++YYCURSOR;
#line 75 "lexer.re"
	{ s->cursor = YYCURSOR; s->error = 1; return 0; }
#line 579 "lexer.c"
yy55:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy56;
		default: goto yy43;
	}
yy56:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy56;
		default: goto yy19;
	}
yy57:
	++YYCURSOR;
	goto yy7;
yy58:
	++YYCURSOR;
#line 120 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_FUNCTION_ABS; }
#line 617 "lexer.c"
yy59:
	++YYCURSOR;
#line 78 "lexer.re"
	{
        // Calculate length, excluding the ${ prefix and the } suffix
        size_t len = YYCURSOR - s->token - 3; // -3 to skip ${ and }
        if (len >= EVAL_MAX_VARIABLE_NAME_LENGTH) {
            len = EVAL_MAX_VARIABLE_NAME_LENGTH - 1;
        }
        memcpy(variable_buffer, s->token + 2, len);
        variable_buffer[len] = '\0';
        lval->strval = strdupz(variable_buffer);
        s->cursor = YYCURSOR;
        return TOK_VARIABLE;
    }
#line 633 "lexer.c"
}
#line 134 "lexer.re"

    }
}

// Function to parse an expression with re2c/lemon
EVAL_NODE *parse_expression_with_re2c_lemon(const char *string, const char **failed_at, int *error) {
    Scanner scanner;
    scanner_init(&scanner, string);

    if(failed_at)
        *failed_at = NULL;
    
    // Use ParseAlloc with mallocz instead of malloc - mallocz will handle allocation failures
    void *parser = ParseAlloc(mallocz);
    
    EVAL_NODE *result = NULL;
    
    YYSTYPE token_value;
    int token_type;
    
    // Initialize error code
    if (error) *error = EVAL_ERROR_OK;
    
    // Save the token start position for error reporting
    const char *error_pos = scanner.cursor;
    
    // Variable to track if we need to free token_value.strval
    int free_strval = 0;
    
    while ((token_type = scan(&scanner, &token_value)) > 0) {
        // If the token is a variable, remember to free it if there's an error
        free_strval = (token_type == TOK_VARIABLE);
        
        Parse(parser, token_type, token_value, &result);
        
        // Save position before potential error
        error_pos = scanner.token;
        
        // Check for syntax errors after each token
        if (result && result->operator == EVAL_OPERATOR_NOP && result->count == 0) {
            // This is an error marker
            if (error) *error = EVAL_ERROR_SYNTAX;
            if (failed_at) {
                *failed_at = error_pos;
            }
            
            // Clean up
            eval_node_free(result);
            ParseFree(parser, freez);
            
            // If we just scanned a variable, free its strval
            if (free_strval && token_value.strval) {
                freez(token_value.strval);
            }
            
            return NULL;
        }
        
        // Reset free_strval since the parser has taken ownership of the string
        free_strval = 0;
    }
    
    // If the last token was a variable and scanning stopped due to an error,
    // we need to free the token_value.strval
    if (free_strval && token_value.strval) {
        freez(token_value.strval);
        token_value.strval = NULL;
    }
    
    // Finish parsing
    Parse(parser, 0, token_value, &result);
    
    // Clean up the parser
    ParseFree(parser, freez);
    
    // Check for lexer errors
    if (scanner.error) {
        if (error) *error = EVAL_ERROR_UNKNOWN_OPERAND;
        if (failed_at) {
            *failed_at = error_pos;
        }
        
        // Clean up result if it was created
        if (result) {
            eval_node_free(result);
        }
        
        return NULL;
    }
    
    if (!result) {
        if (error) *error = EVAL_ERROR_SYNTAX;
        if (failed_at) {
            *failed_at = error_pos;
        }
        return NULL;
    }
    
    if (failed_at)
        *failed_at = NULL;
    
    return result;
}