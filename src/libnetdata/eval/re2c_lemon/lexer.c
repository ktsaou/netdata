/* Generated by re2c 4.1 on Thu Apr 17 14:25:47 2025 */
#line 1 "lexer.re"
/**
 * re2c lexer for Netdata's expression evaluator
 *
 * This implementation uses re2c for lexical analysis and lemon for parsing.
 * It is fully integrated with Netdata's existing EVAL_NODE structure.
 */

#include "../eval-internal.h"
#include "parser_internal.h"

// Scanner functions implementation
void scanner_init(Scanner *s, const char *input) {
    if (!input) {
        // Handle NULL input safely
        s->cursor = "";
        s->marker = s->cursor;
        s->token = s->cursor;
        s->limit = s->cursor;
        s->line = 1;
        s->error = 1;  // Set error flag for NULL input
        s->in_assignment = 0; // Initialize assignment context flag
        return;
    }
    
    s->cursor = input;
    s->marker = s->cursor;
    s->token = s->cursor;
    s->limit = s->cursor + strlen(s->cursor);
    s->line = 1;
    s->error = 0;  // Initialize error flag
    s->in_assignment = 0; // Initialize assignment context flag
}

int scan(Scanner *s, YYSTYPE *lval) {
    const char *YYMARKER;
    const char *YYCURSOR = s->cursor;
    char variable_buffer[EVAL_MAX_VARIABLE_NAME_LENGTH + 1] = {0};
    
    // Skip whitespace
    while (1) {
        s->token = YYCURSOR;
        

#line 47 "lexer.c"
{
	char yych;
	unsigned int yyaccept = 0;
	yych = *YYCURSOR;
	switch (yych) {
		case 0x00: goto yy1;
		case '\t':
		case ' ': goto yy4;
		case '\n':
		case '\r': goto yy6;
		case '!': goto yy8;
		case '$': goto yy10;
		case '%': goto yy11;
		case '&': goto yy12;
		case '(': goto yy13;
		case ')': goto yy14;
		case '*': goto yy15;
		case '+': goto yy16;
		case '-': goto yy17;
		case '.': goto yy18;
		case '/': goto yy19;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy20;
		case ':': goto yy22;
		case ';': goto yy23;
		case '<': goto yy24;
		case '=': goto yy26;
		case '>': goto yy28;
		case '?': goto yy30;
		case 'A':
		case 'a': goto yy31;
		case 'I':
		case 'i': goto yy32;
		case 'N':
		case 'n': goto yy33;
		case 'O':
		case 'o': goto yy34;
		case '|': goto yy35;
		default: goto yy2;
	}
yy1:
	++YYCURSOR;
#line 180 "lexer.re"
	{ s->cursor = YYCURSOR; return 0; }
#line 100 "lexer.c"
yy2:
	++YYCURSOR;
yy3:
#line 183 "lexer.re"
	{ 
        s->cursor = YYCURSOR; 
        s->error = 1;  // Set error flag
        return 0;      // Return 0 to stop parsing
    }
#line 110 "lexer.c"
yy4:
	yych = *++YYCURSOR;
	switch (yych) {
		case '\t':
		case ' ': goto yy4;
		default: goto yy5;
	}
yy5:
#line 48 "lexer.re"
	{ continue; }
#line 121 "lexer.c"
yy6:
	yych = *++YYCURSOR;
	switch (yych) {
		case '\n':
		case '\r': goto yy6;
		default: goto yy7;
	}
yy7:
#line 51 "lexer.re"
	{ 
        s->cursor = YYCURSOR; 
        s->in_assignment = 0; 
        return TOK_SEMICOLON; 
    }
#line 136 "lexer.c"
yy8:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy36;
		default: goto yy9;
	}
yy9:
#line 144 "lexer.re"
	{ 
        s->cursor = YYCURSOR; 
        return TOK_NOT; 
    }
#line 149 "lexer.c"
yy10:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00:
		case '\t':
		case '\n':
		case '\r':
		case ' ':
		case '!':
		case '%':
		case '&':
		case '(':
		case ')':
		case '*':
		case '+':
		case '-':
		case '/':
		case ';':
		case '<':
		case '=':
		case '>':
		case '?':
		case '|':
		case '}': goto yy3;
		case '{': goto yy39;
		default: goto yy37;
	}
yy11:
	++YYCURSOR;
#line 129 "lexer.re"
	{ s->cursor = YYCURSOR; s->in_assignment = 0; return TOK_MODULO; }
#line 181 "lexer.c"
yy12:
	yych = *++YYCURSOR;
	switch (yych) {
		case '&': goto yy41;
		default: goto yy3;
	}
yy13:
	++YYCURSOR;
#line 169 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_LPAREN; }
#line 192 "lexer.c"
yy14:
	++YYCURSOR;
#line 170 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_RPAREN; }
#line 197 "lexer.c"
yy15:
	++YYCURSOR;
#line 127 "lexer.re"
	{ s->cursor = YYCURSOR; s->in_assignment = 0; return TOK_MULTIPLY; }
#line 202 "lexer.c"
yy16:
	++YYCURSOR;
#line 125 "lexer.re"
	{ s->cursor = YYCURSOR; s->in_assignment = 0; return TOK_PLUS; }
#line 207 "lexer.c"
yy17:
	++YYCURSOR;
#line 126 "lexer.re"
	{ s->cursor = YYCURSOR; s->in_assignment = 0; return TOK_MINUS; }
#line 212 "lexer.c"
yy18:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy42;
		default: goto yy3;
	}
yy19:
	++YYCURSOR;
#line 128 "lexer.re"
	{ s->cursor = YYCURSOR; s->in_assignment = 0; return TOK_DIVIDE; }
#line 232 "lexer.c"
yy20:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '.': goto yy42;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy20;
		case 'E':
		case 'e': goto yy43;
		default: goto yy21;
	}
yy21:
#line 82 "lexer.re"
	{
        char *endptr;
        lval->dval = str2ndd(s->token, &endptr);
        s->cursor = YYCURSOR;
        s->in_assignment = 0; // Reset assignment context
        return TOK_NUMBER;
    }
#line 261 "lexer.c"
yy22:
	++YYCURSOR;
#line 166 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_COLON; }
#line 266 "lexer.c"
yy23:
	++YYCURSOR;
#line 130 "lexer.re"
	{ s->cursor = YYCURSOR; s->in_assignment = 0; return TOK_SEMICOLON; }
#line 271 "lexer.c"
yy24:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy45;
		case '>': goto yy36;
		default: goto yy25;
	}
yy25:
#line 159 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_LT; }
#line 282 "lexer.c"
yy26:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy46;
		default: goto yy27;
	}
yy27:
#line 151 "lexer.re"
	{ 
        s->cursor = YYCURSOR;
        // If we're after a variable, it's an assignment, otherwise it's equality
        int token = s->in_assignment ? TOK_ASSIGN : TOK_EQ;
        s->in_assignment = 0; // Reset assignment context
        return token;
    }
#line 298 "lexer.c"
yy28:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy47;
		default: goto yy29;
	}
yy29:
#line 161 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_GT; }
#line 308 "lexer.c"
yy30:
	++YYCURSOR;
#line 165 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_QMARK; }
#line 313 "lexer.c"
yy31:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'B':
		case 'b': goto yy48;
		case 'N':
		case 'n': goto yy49;
		default: goto yy3;
	}
yy32:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'N':
		case 'n': goto yy50;
		default: goto yy3;
	}
yy33:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'A':
		case 'a': goto yy51;
		case 'O':
		case 'o': goto yy52;
		case 'U':
		case 'u': goto yy53;
		default: goto yy3;
	}
yy34:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'R':
		case 'r': goto yy54;
		default: goto yy3;
	}
yy35:
	yych = *++YYCURSOR;
	switch (yych) {
		case '|': goto yy54;
		default: goto yy3;
	}
yy36:
	++YYCURSOR;
#line 158 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_NE; }
#line 361 "lexer.c"
yy37:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00:
		case '\t':
		case '\n':
		case '\r':
		case ' ':
		case '!':
		case '%':
		case '&':
		case '(':
		case ')':
		case '*':
		case '+':
		case '-':
		case '/':
		case ';':
		case '<':
		case '=':
		case '>':
		case '?':
		case '{':
		case '|':
		case '}': goto yy38;
		default: goto yy37;
	}
yy38:
#line 93 "lexer.re"
	{
        size_t len = YYCURSOR - s->token - 1; // -1 to skip the $
        if (len >= EVAL_MAX_VARIABLE_NAME_LENGTH) {
            len = EVAL_MAX_VARIABLE_NAME_LENGTH - 1;
        }
        memcpy(variable_buffer, s->token + 1, len);
        variable_buffer[len] = '\0';
        lval->strval = strdupz(variable_buffer);
        s->cursor = YYCURSOR;
        s->in_assignment = 1; // Mark that we just saw a variable, potential assignment context
        return TOK_VARIABLE;
    }
#line 403 "lexer.c"
yy39:
	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 0x00: goto yy40;
		case '}': goto yy56;
		default: goto yy55;
	}
yy40:
#line 177 "lexer.re"
	{ s->cursor = YYCURSOR; s->error = 1; return 0; }
#line 415 "lexer.c"
yy41:
	++YYCURSOR;
#line 134 "lexer.re"
	{ 
        s->cursor = YYCURSOR; 
        return TOK_AND; 
    }
#line 423 "lexer.c"
yy42:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy42;
		case 'E':
		case 'e': goto yy43;
		default: goto yy21;
	}
yy43:
	yych = *++YYCURSOR;
	switch (yych) {
		case '+':
		case '-': goto yy57;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy58;
		default: goto yy44;
	}
yy44:
	YYCURSOR = YYMARKER;
	switch (yyaccept) {
		case 0: goto yy21;
		case 1: goto yy3;
		case 2: goto yy40;
		default: goto yy61;
	}
yy45:
	++YYCURSOR;
#line 160 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_LE; }
#line 471 "lexer.c"
yy46:
	++YYCURSOR;
#line 150 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_EQ; }
#line 476 "lexer.c"
yy47:
	++YYCURSOR;
#line 162 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_GE; }
#line 481 "lexer.c"
yy48:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'S':
		case 's': goto yy59;
		default: goto yy44;
	}
yy49:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'D':
		case 'd': goto yy41;
		default: goto yy44;
	}
yy50:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'F':
		case 'f': goto yy60;
		default: goto yy44;
	}
yy51:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'N':
		case 'n': goto yy62;
		default: goto yy44;
	}
yy52:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'T':
		case 't': goto yy63;
		default: goto yy44;
	}
yy53:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'L':
		case 'l': goto yy64;
		default: goto yy44;
	}
yy54:
	++YYCURSOR;
#line 139 "lexer.re"
	{ 
        s->cursor = YYCURSOR; 
        return TOK_OR; 
    }
#line 531 "lexer.c"
yy55:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy44;
		case '}': goto yy65;
		default: goto yy55;
	}
yy56:
	++YYCURSOR;
#line 107 "lexer.re"
	{ s->cursor = YYCURSOR; s->error = 1; return 0; }
#line 543 "lexer.c"
yy57:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy58;
		default: goto yy44;
	}
yy58:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy58;
		default: goto yy21;
	}
yy59:
	++YYCURSOR;
#line 174 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_FUNCTION_ABS; }
#line 578 "lexer.c"
yy60:
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'I':
		case 'i': goto yy66;
		default: goto yy61;
	}
yy61:
#line 69 "lexer.re"
	{
        lval->dval = INFINITY;
        s->cursor = YYCURSOR;
        s->in_assignment = 0; // Reset assignment context
        return TOK_NUMBER;
    }
#line 595 "lexer.c"
yy62:
	++YYCURSOR;
#line 60 "lexer.re"
	{
        lval->dval = NAN;
        s->cursor = YYCURSOR;
        s->in_assignment = 0; // Reset assignment context
        return TOK_NUMBER;
    }
#line 605 "lexer.c"
yy63:
	++YYCURSOR;
	goto yy9;
yy64:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'L':
		case 'l': goto yy62;
		default: goto yy44;
	}
yy65:
	++YYCURSOR;
#line 110 "lexer.re"
	{
        // Calculate length, excluding the ${ prefix and the } suffix
        size_t len = YYCURSOR - s->token - 3; // -3 to skip ${ and }
        if (len >= EVAL_MAX_VARIABLE_NAME_LENGTH) {
            len = EVAL_MAX_VARIABLE_NAME_LENGTH - 1;
        }
        memcpy(variable_buffer, s->token + 2, len);
        variable_buffer[len] = '\0';
        lval->strval = strdupz(variable_buffer);
        s->cursor = YYCURSOR;
        s->in_assignment = 1; // Mark that we just saw a variable, potential assignment context
        return TOK_VARIABLE;
    }
#line 632 "lexer.c"
yy66:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'N':
		case 'n': goto yy67;
		default: goto yy44;
	}
yy67:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'I':
		case 'i': goto yy68;
		default: goto yy44;
	}
yy68:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'T':
		case 't': goto yy69;
		default: goto yy44;
	}
yy69:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'Y':
		case 'y': goto yy70;
		default: goto yy44;
	}
yy70:
	++YYCURSOR;
	goto yy61;
}
#line 188 "lexer.re"

    }
}

// Function to parse an expression with re2c/lemon
EVAL_NODE *parse_expression_with_re2c_lemon(const char *string, const char **failed_at, int *error) {
    Scanner scanner;
    scanner_init(&scanner, string);

    if(failed_at)
        *failed_at = NULL;
    
    // Use ParseAlloc with mallocz instead of malloc - mallocz will handle allocation failures
    void *parser = ParseAlloc(mallocz);
    
    EVAL_NODE *result = NULL;
    
    YYSTYPE token_value;
    int token_type;
    
    // Initialize error code
    if (error) *error = EVAL_ERROR_OK;
    
    // Save the token start position for error reporting
    const char *error_pos = scanner.cursor;
    
    // Variable to track if we need to free token_value.strval
    int free_strval = 0;
    
    while ((token_type = scan(&scanner, &token_value)) > 0) {
        // If the token is a variable, remember to free it if there's an error
        free_strval = (token_type == TOK_VARIABLE);
        
        Parse(parser, token_type, token_value, &result);
        
        // Save position before potential error
        error_pos = scanner.token;
        
        // Check for syntax errors after each token
        if (result && result->operator == EVAL_OPERATOR_NOP && result->count == 0) {
            // This is an error marker
            if (error) *error = EVAL_ERROR_SYNTAX;
            if (failed_at) {
                *failed_at = error_pos;
            }
            
            // Clean up
            eval_node_free(result);
            ParseFree(parser, freez);
            
            // If we just scanned a variable, free its strval
            if (free_strval && token_value.strval) {
                freez(token_value.strval);
            }
            
            return NULL;
        }
        
        // Reset free_strval since the parser has taken ownership of the string
        free_strval = 0;
    }
    
    // If the last token was a variable and scanning stopped due to an error,
    // we need to free the token_value.strval
    if (free_strval && token_value.strval) {
        freez(token_value.strval);
        token_value.strval = NULL;
    }
    
    // Finish parsing
    Parse(parser, 0, token_value, &result);
    
    // Clean up the parser
    ParseFree(parser, freez);
    
    // Check for lexer errors
    if (scanner.error) {
        if (error) *error = EVAL_ERROR_UNKNOWN_OPERAND;
        if (failed_at) {
            *failed_at = error_pos;
        }
        
        // Clean up result if it was created
        if (result) {
            eval_node_free(result);
        }
        
        return NULL;
    }
    
    if (!result) {
        if (error) *error = EVAL_ERROR_SYNTAX;
        if (failed_at) {
            *failed_at = error_pos;
        }
        return NULL;
    }
    
    if (failed_at)
        *failed_at = NULL;
    
    return result;
}