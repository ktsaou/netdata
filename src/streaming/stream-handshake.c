// SPDX-License-Identifier: GPL-3.0-or-later

#include "stream.h"

static struct {
    STREAM_HANDSHAKE err;
    const char *str;
} handshake_errors[] = {
    {STREAM_HANDSHAKE_OK_V3, "CONNECTED"},
    {STREAM_HANDSHAKE_OK_V2, "CONNECTED"},
    {STREAM_HANDSHAKE_OK_V1, "CONNECTED"},
    {STREAM_HANDSHAKE_NEVER, ""},
    {STREAM_HANDSHAKE_ERROR_BAD_HANDSHAKE, "BAD HANDSHAKE"},
    {STREAM_HANDSHAKE_ERROR_LOCALHOST, "LOCALHOST"},
    {STREAM_HANDSHAKE_ERROR_ALREADY_CONNECTED, "ALREADY CONNECTED"},
    {STREAM_HANDSHAKE_ERROR_DENIED, "DENIED"},
    {STREAM_HANDSHAKE_ERROR_SEND_TIMEOUT, "SEND TIMEOUT"},
    {STREAM_HANDSHAKE_ERROR_RECEIVE_TIMEOUT, "RECEIVE TIMEOUT"},
    {STREAM_HANDSHAKE_ERROR_INVALID_CERTIFICATE, "INVALID CERTIFICATE"},
    {STREAM_HANDSHAKE_ERROR_SSL_ERROR, "SSL ERROR"},
    {STREAM_HANDSHAKE_ERROR_CANT_CONNECT, "CANT CONNECT"},
    {STREAM_HANDSHAKE_BUSY_TRY_LATER, "BUSY TRY LATER"},
    {STREAM_HANDSHAKE_INTERNAL_ERROR, "INTERNAL ERROR"},
    {STREAM_HANDSHAKE_INITIALIZATION, "REMOTE IS INITIALIZING"},

    // receiver only codes
    {STREAM_HANDSHAKE_RCV_DISCONNECT_PARSER_FAILED, "DISCONNECTED PARSE ERROR"},
    {STREAM_HANDSHAKE_RCV_DISCONNECT_STALE_RECEIVER, "DISCONNECTED STALE RECEIVER"},
    {STREAM_HANDSHAKE_RCV_DECOMPRESSION_FAILED, "DISCONNECTED DECOMPRESSION FAILED"},

    // sender only codes
    {STREAM_HANDSHAKE_SND_DISCONNECT_HOST_CLEANUP, "DISCONNECTED HOST CLEANUP"},
    {STREAM_HANDSHAKE_SND_DISCONNECT_COMPRESSION_FAILED, "DISCONNECTED SND COMPRESSION FAILED"},
    {STREAM_HANDSHAKE_SND_DISCONNECT_HTTP_UPGRADE_FAILED, "HTTP UPGRADE ERROR"},

    // receiver and sender codes
    {STREAM_HANDSHAKE_DISCONNECT_SIGNALED_TO_STOP, "DISCONNECTED SIGNALED TO STOP"},
    {STREAM_HANDSHAKE_DISCONNECT_SHUTDOWN, "DISCONNECTED SHUTDOWN REQUESTED"},
    {STREAM_HANDSHAKE_DISCONNECT_SOCKET_READ_FAILED, "DISCONNECTED SOCKET READ FAILED"},
    {STREAM_HANDSHAKE_DISCONNECT_SOCKET_WRITE_FAILED, "DISCONNECTED SOCKET WRITE FAILED"},
    {STREAM_HANDSHAKE_DISCONNECT_SOCKET_ERROR, "DISCONNECT SOCKET ERROR"},
    {STREAM_HANDSHAKE_DISCONNECT_TIMEOUT, "DISCONNECTED TIMEOUT"},
    {STREAM_HANDSHAKE_DISCONNECT_SOCKET_CLOSED_BY_REMOTE, "DISCONNECTED SOCKET CLOSED BY REMOTE END"},
    {STREAM_HANDSHAKE_DISCONNECT_BUFFER_OVERFLOW, "DISCONNECTED NOT SUFFICIENT SEND BUFFER"},
    {STREAM_HANDSHAKE_DISCONNECT_REPLICATION_STALLED, "REPLICATION STALLED"},

    // sender (stream parents - SP) failures to connect
    {STREAM_HANDSHAKE_SP_PREPARING, "PREPARING"},
    {STREAM_HANDSHAKE_SP_NO_HOST_IN_DESTINATION, "NO HOST IN DESTINATION - CONFIG ERROR"},
    {STREAM_HANDSHAKE_SP_CONNECT_TIMEOUT, "CONNECT TIMEOUT"},
    {STREAM_HANDSHAKE_SP_CONNECTION_REFUSED, "CONNECTION REFUSED"},
    {STREAM_HANDSHAKE_SP_CANT_RESOLVE_HOSTNAME, "CANT RESOLVE HOSTNAME"},
    {STREAM_HANDSHAKE_SP_CONNECTING, "CONNECTING"},
    {STREAM_HANDSHAKE_SP_CONNECTED, "CONNECTED"},
    {STREAM_HANDSHAKE_SP_NO_STREAM_INFO, "NO STREAM INFO"},

    { 0, NULL },
};

const char *stream_handshake_error_to_string(STREAM_HANDSHAKE reason) {
    if(reason >= STREAM_HANDSHAKE_OK_V1)
        // handshake_error is the whole version / capabilities number
        return "CONNECTED";

    for(size_t i = 0; handshake_errors[i].str ; i++) {
        if(reason == handshake_errors[i].err)
            return handshake_errors[i].str;
    }

    return "UNKNOWN";
}
