<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netdata MCP WebSocket Test</title>
    <!-- JSON Editor for schema-based forms -->
    <script src="https://cdn.jsdelivr.net/npm/@json-editor/json-editor@latest/dist/jsoneditor.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@json-editor/json-editor@latest/dist/css/jsoneditor.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px;
            line-height: 1.6;
            color: #333;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }
        h1 {
            color: #0088cc;
            margin-top: 0;
            margin-bottom: 10px;
        }
        .connection-panel {
            background-color: #e2f4ff;
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }
        .four-column-layout {
            display: grid;
            grid-template-columns: 112px 216px 1fr 2fr;
            gap: 10px;
            height: calc(100vh - 120px);
            min-height: 500px;
        }
        .column {
            background-color: #f5f5f5;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative; /* Added for absolute positioning of buttons */
        }
        /* Keep methods column scrollable */
        .column:nth-child(2) {
            overflow: hidden !important;
        }
        .column:nth-child(2) .column-content {
            overflow-y: auto !important;
            overflow-x: hidden !important;
        }
        .column-header {
            margin-top: 0;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #ddd;
            font-size: 1.2em;
            color: #0088cc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .column-content {
            overflow-y: auto;
            overflow-x: visible;
            flex: 1;
        }
        .flow-item, .method-item {
            padding: 8px;
            margin-bottom: 6px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .flow-item {
            font-size: 0.9em;
        }
        .method-item {
            font-size: 0.85em;
        }
        .flow-item:hover, .method-item:hover {
            background-color: #e0e0e0;
        }
        .flow-item.active, .method-item.active {
            background-color: #d0e8f2;
            font-weight: bold;
        }
        .method-item.dynamic {
            border-left: 3px solid #0088cc;
            background-color: #f0f8ff;
        }
        .method-item.dynamic:hover {
            background-color: #e0f0ff;
        }
        /* Smaller font for method descriptions in tooltips */
        .method-item .tooltip {
            font-size: 0.8em;
            margin-left: 4px;
        }
        .method-item.history {
            border-left: 3px solid #666;
            background-color: #f8f8f8;
        }
        .method-item.history:hover {
            background-color: #eeeeee;
        }
        .method-item.history.error {
            border-left-color: #d00;
            background-color: #fff5f5;
        }
        .method-item.history.error:hover {
            background-color: #ffeeee;
        }
        #jsonEditor {
            width: 100%;
            height: 100%;
            font-family: monospace;
            font-size: 14px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
            resize: none;
            box-sizing: border-box;
        }
        /* JSON syntax highlighting */
        .json-string { 
            color: #008800; 
            font-weight: bold;
            display: inline-block; /* Allow multiline strings to format properly */
        }
        .json-number { color: #0055aa; font-weight: bold; }
        .json-boolean-true { color: #008800; font-weight: bold; }
        .json-boolean-false { color: #dd0000; font-weight: bold; }
        .json-null { color: #666666; font-weight: bold; }
        .json-key { color: #555555; }
        .json-bracket { color: #aaaaaa; }
        .json-comma { color: #aaaaaa; }
        .json-colon { color: #aaaaaa; }
        #requestData {
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            overflow: auto;
            white-space: pre-wrap;
            max-height: 100px;
        }
        button {
            background-color: #0088cc;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #006699;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .button-row {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        .status {
            font-weight: bold;
        }
        .connected {
            color: green;
        }
        .disconnected {
            color: red;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: #555;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 9999;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
        }
        /* Specific positioning for method tooltips */
        .method-item.tooltip .tooltiptext {
            position: fixed;
            z-index: 9999;
            width: 300px;
            max-width: 400px;
            height: auto !important;
            min-height: fit-content;
            white-space: normal;
            word-wrap: break-word;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        /* Schema editor field tooltips */
        .schema-field-info {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background-color: #0088cc;
            color: white;
            text-align: center;
            line-height: 14px;
            font-size: 10px;
            font-weight: bold;
            cursor: help;
            margin-left: 6px;
            position: relative;
        }
        /* Real tooltip div */
        .schema-field-tooltip {
            position: fixed;
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            white-space: normal;
            width: 325px;
            max-width: 390px;
            font-size: 12px;
            font-weight: normal;
            line-height: 1.4;
            z-index: 10000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            pointer-events: none;
            display: none;
        }
        
        /* Ensure JSON content wraps properly */
        pre, #responseViewer, #requestData {
            white-space: pre-wrap !important;
            word-break: break-word !important;
            overflow-x: auto !important;
        }
        
        /* Tab styles */
        .tabs {
            display: flex;
            border-bottom: 2px solid #ddd;
            margin-bottom: 10px;
        }
        .tab {
            padding: 8px 16px;
            cursor: pointer;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-bottom: none;
            margin-right: 4px;
            transition: background-color 0.2s;
            font-size: 0.9em;
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }
        .tab:hover {
            background-color: #e0e0e0;
        }
        .tab.active {
            background-color: white;
            font-weight: bold;
            border-bottom: 2px solid white;
            margin-bottom: -2px;
        }
        .tab-content {
            display: none;
            height: 100%;
            position: relative;
        }
        .tab-content.active {
            display: block;
        }
        #editRequestContent.active {
            display: flex !important;
        }
        /* JSON Editor customization */
        #editRequestContent {
            height: 100%;
            overflow: hidden;
            flex-direction: column;
        }
        #schemaFormEditor {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-height: 0; /* Important for flex child with overflow */
            font-size: 11.56px !important; /* Base font size for all children */
            line-height: 1.3 !important; /* Base line height for all children */
        }
        .je-object__container {
            border: none !important;
        }
        /* Hide only the root object header, not array headers */
        #schemaFormEditor > div > .je-header.je-object__title {
            display: none !important;
        }
        /* Hide only the root text in the object title */
        .je-header.je-object__title > span:not(button) {
            display: none !important;
        }
        /* Hide the collapse, edit json, and object properties buttons */
        #schemaFormEditor .json-editor-btnholder.je-object__controls {
            display: none !important;
        }
        #schemaFormEditor button.json-editor-btn-collapse,
        #schemaFormEditor button.json-editor-btn-edit,
        #schemaFormEditor button.json-editor-btn-properties,
        #schemaFormEditor button.json-editor-btn-edit_properties,
        #schemaFormEditor button.json-editor-btntype-properties,
        #schemaFormEditor button[title="Object Properties"],
        #schemaFormEditor button[title*="Properties"],
        #schemaFormEditor button[title*="properties"] {
            display: none !important;
        }
        /* Hide the root level button holder */
        #schemaFormEditor > div > .json-editor-btnholder {
            display: none !important;
        }
        /* Make JSON Editor fonts smaller */
        #schemaFormEditor label {
            font-size: inherit !important;
            font-weight: normal !important;
        }
        /* Force all text elements to not be bold */
        #schemaFormEditor * {
            font-weight: normal !important;
        }
        /* Only make actual labels (field names) slightly bolder */
        #schemaFormEditor > div > label,
        #schemaFormEditor .form-group > label,
        #schemaFormEditor label[for^="root["],
        #schemaFormEditor .je-header > span:not(button):not(.je-header-button-holder) {
            font-weight: 500 !important;
            padding-left: 10px !important;
            padding-right: 10px !important;
        }
        #schemaFormEditor input,
        #schemaFormEditor select,
        #schemaFormEditor textarea {
            font-size: inherit !important;
            padding: 4px 8px !important;
        }
        #schemaFormEditor .form-control {
            font-size: inherit !important;
            height: auto !important;
            padding: 4px 8px !important;
        }
        #schemaFormEditor p {
            font-size: 0.9em !important;
            margin: 2px 0 !important;
            font-weight: normal !important;
        }
        #schemaFormEditor .help-block,
        #schemaFormEditor .help-inline,
        #schemaFormEditor p.help-block,
        #schemaFormEditor p.help-inline {
            font-size: 0.85em !important;
            margin-top: 2px !important;
            font-weight: normal !important;
        }
        #schemaFormEditor .form-group {
            margin-bottom: 10px !important;
        }
        #schemaFormEditor h3 {
            font-size: 1em !important;
            margin: 10px 0 5px 0 !important;
        }
        /* Ensure array titles are shown */
        #schemaFormEditor .je-array-control-title {
            display: block !important;
            font-size: inherit !important;
            font-weight: normal !important;
            margin-bottom: 4px !important;
        }
        #schemaFormEditor .je-indented-panel {
            margin-top: 8px !important;
        }
        /* Style the array container labels */
        #schemaFormEditor div[data-schemapath*="nodes"] > label:first-child,
        #schemaFormEditor .je-object__title {
            display: block !important;
            font-size: inherit !important;
            margin-bottom: 4px !important;
        }
        /* Add padding to array descriptions to match other fields */
        #schemaFormEditor div[data-schematype="array"] > p,
        #schemaFormEditor div[data-schematype="array"] > .help-block {
            padding-left: 10px !important;
            padding-right: 10px !important;
            font-size: 0.85em !important;
            font-weight: normal !important;
        }
        /* Force array field fonts to be same size as other fields - more specific */
        #schemaFormEditor [data-schematype="array"] label,
        #schemaFormEditor [data-schemapath*="root."] > label,
        #schemaFormEditor .array-field-label {
            font-size: inherit !important;
        }
        /* Style array headers to match regular field labels */
        #schemaFormEditor .je-header {
            padding-left: 10px !important;
            padding-right: 10px !important;
            margin-bottom: 4px !important;
        }
        #schemaFormEditor .je-header > span:not(button):not(.je-header-button-holder) {
            font-size: inherit !important;
            font-weight: 500 !important;
        }
        #schemaFormEditor [data-schematype="array"] p,
        #schemaFormEditor [data-schematype="array"] .help-block,
        #schemaFormEditor [data-schemapath*="root."] > p,
        #schemaFormEditor [data-schemapath*="nodes"] p {
            font-size: 0.85em !important;
        }
        /* Override any inline styles on array elements - very specific */
        #schemaFormEditor [data-schemapath="root.nodes"] > label.array-field-label {
            font-size: inherit !important;
        }
        #schemaFormEditor [data-schemapath="root.nodes"] > p,
        #schemaFormEditor [data-schemapath="root.nodes"] > .help-block {
            font-size: 0.85em !important;
        }
        /* Target any remaining array field text */
        div[data-schematype="array"] > :not(button):not(input):not(select):not(textarea) {
            max-width: 100%;
        }
        /* Style all array control buttons consistently */
        #schemaFormEditor .json-editor-btn-add,
        #schemaFormEditor .json-editor-btn-delete,
        #schemaFormEditor .json-editor-btn-deleteall,
        #schemaFormEditor .json-editor-btn-deletelast,
        #schemaFormEditor button {
            font-size: 0.9em !important;
            padding: 3px 10px !important;
            margin: 2px !important;
            display: inline-block !important;
            visibility: visible !important;
            background-color: #ffffff !important;
            border: 1px solid #0088cc !important;
            border-radius: 3px !important;
            cursor: pointer !important;
            color: #0088cc !important;
            font-weight: normal !important;
            text-decoration: none !important;
        }
        #schemaFormEditor button:hover {
            background-color: #0088cc !important;
            color: #ffffff !important;
        }
    </style>
</head>
<body>
    <h1>Netdata MCP WebSocket Test</h1>
    
    <div class="connection-panel">
        <label for="serverUrl">WebSocket Server URL:</label>
        <input type="text" id="serverUrl" value="ws://localhost:19999/mcp" style="width: 300px;">
        <button id="connectBtn">Connect</button>
        <button id="disconnectBtn" disabled>Disconnect</button>
        <span id="status" class="status disconnected">Disconnected</span>
    </div>
    
    <div class="four-column-layout">
        <!-- First Column - Flows -->
        <div class="column">
            <h3 class="column-header">Flows</h3>
            <div class="column-content" id="flowsContainer">
                <div class="flow-item active" data-flow="initialize-flow">Initialize</div>
                <div class="flow-item" data-flow="ping-flow">Ping</div>
                <div class="flow-item" data-flow="tools-flow">Tools</div>
                <div class="flow-item" data-flow="resources-flow">Resources</div>
                <div class="flow-item" data-flow="prompts-flow">Prompts</div>
                <div class="flow-item" data-flow="logging-flow">Logging</div>
                <div class="flow-item" data-flow="completion-flow">Completion</div>
                <div class="flow-item" data-flow="history-flow">History</div>
            </div>
        </div>
        
        <!-- Second Column - Methods -->
        <div class="column">
            <h3 class="column-header" id="methodsHeader">Methods</h3>
            <div class="column-content" id="methodsContainer">
                <!-- Methods will be loaded here -->
            </div>
        </div>
        
        <!-- Third Column - Request Editor -->
        <div class="column">
            <h3 class="column-header">
                Request
                <span class="tooltip">ⓘ
                    <span class="tooltiptext">
                        JSON-RPC 2.0 request format requires "jsonrpc": "2.0", "method" and an optional "id".
                    </span>
                </span>
            </h3>
            <div style="display: flex; flex-direction: column; height: calc(100% - 45px);">
                <!-- Tabs -->
                <div class="tabs" style="flex-shrink: 0;">
                    <div class="tab active" id="editRequestTab" data-tab="editRequest">Edit Request</div>
                    <div class="tab" id="schemaTab" data-tab="schema">Schema</div>
                    <div class="tab" id="rawTab" data-tab="raw">Raw</div>
                </div>
                
                <!-- Tab Contents - 50% height -->
                <div style="height: 50%; position: relative; overflow: hidden;">
                    <!-- Edit Request Tab - Schema Form -->
                    <div id="editRequestContent" class="tab-content active">
                        <div id="schemaFormEditor"></div>
                        <div id="noSchemaMessage" style="padding: 20px; text-align: center; color: #666;">
                            <p>No schema available for this method.</p>
                            <p style="font-size: 0.9em;">Use the Raw tab to edit the request manually.</p>
                        </div>
                    </div>
                    
                    <!-- Schema Tab - View Schema -->
                    <div id="schemaContent" class="tab-content">
                        <pre id="schemaViewer" style="height: 100%; margin: 0; padding: 10px; background-color: #f8f8f8; border: 1px solid #ddd; border-radius: 4px; overflow: auto; font-family: monospace; font-size: 12px;"></pre>
                    </div>
                    
                    <!-- Raw Tab - Manual JSON Editor -->
                    <div id="rawContent" class="tab-content">
                        <textarea id="jsonEditor" style="height: 100%; width: 100%; resize: none; box-sizing: border-box;"></textarea>
                    </div>
                </div>
                
                <!-- Log container - flex to fill remaining space minus buttons -->
                <div style="flex: 1; display: flex; flex-direction: column; padding: 8px 0; min-height: 0; overflow: hidden;">
                    <div id="requestData" style="background-color: #f0f0f0; padding: 6px; border-radius: 4px; margin-bottom: 4px; font-family: monospace; font-size: 12px; white-space: pre-wrap; word-break: break-word; height: 60px; overflow: auto; flex-shrink: 0;"></div>
                    <pre id="commLog" style="flex: 1; background-color: #f8f8f8; border: 1px solid #ddd; border-radius: 4px; padding: 6px; font-family: monospace; font-size: 12px; overflow: auto; margin: 0; min-height: 0;"></pre>
                </div>
                
                <!-- Buttons at the bottom -->
                <div class="button-row" style="padding: 5px 0; flex-shrink: 0;">
                    <button id="sendBtn" disabled>Send</button>
                    <button id="resetBtn">Reset</button>
                    <button id="clearLogBtn">Clear Log</button>
                </div>
            </div>
        </div>
        
        <!-- Fourth Column - Response Viewer -->
        <div class="column">
            <h3 class="column-header">
                Response
                <div style="float: right; font-size: 0.8em;">
                    <label style="font-weight: normal; cursor: pointer;">
                        <input type="checkbox" id="rawViewToggle" style="margin-right: 4px;">
                        Raw View
                    </label>
                </div>
            </h3>
            <div style="display: flex; flex-direction: column; height: calc(100% - 35px);">
                <pre id="responseViewer" style="flex: 1; overflow: auto; margin: 0; padding: 6px; background-color: #f8f8f8; border: 1px solid #ddd; border-radius: 4px; white-space: pre-wrap; word-break: break-word;"><span class="json-null">No response yet.</span></pre>
            </div>
        </div>
    </div>

    <script>
        // DOM elements
        const serverUrlInput = document.getElementById('serverUrl');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusSpan = document.getElementById('status');
        const jsonEditor = document.getElementById('jsonEditor');
        const sendBtn = document.getElementById('sendBtn');
        const resetBtn = document.getElementById('resetBtn');
        const clearLogBtn = document.getElementById('clearLogBtn');
        const responseViewer = document.getElementById('responseViewer');
        const requestData = document.getElementById('requestData');
        const commLog = document.getElementById('commLog');
        const flowsContainer = document.getElementById('flowsContainer');
        const methodsContainer = document.getElementById('methodsContainer');
        const methodsHeader = document.getElementById('methodsHeader');
        const rawViewToggle = document.getElementById('rawViewToggle');
        
        // Tab elements
        const editRequestTab = document.getElementById('editRequestTab');
        const schemaTab = document.getElementById('schemaTab');
        const rawTab = document.getElementById('rawTab');
        const editRequestContent = document.getElementById('editRequestContent');
        const schemaContent = document.getElementById('schemaContent');
        const rawContent = document.getElementById('rawContent');
        const schemaFormEditor = document.getElementById('schemaFormEditor');
        const schemaViewer = document.getElementById('schemaViewer');
        const noSchemaMessage = document.getElementById('noSchemaMessage');
        
        // WebSocket connection
        let socket = null;
        let requestId = 1;
        let isConnected = false;
        let requestTimestamp = null;
        
        // Store current response data
        let currentResponseRaw = null;
        let currentResponseParsed = null;
        let currentResponseError = null;
        
        // Flags to track dynamic items
        let dynamicToolsLoaded = false;
        let dynamicResourcesLoaded = false;
        let dynamicPromptsLoaded = false;
        
        // Request history
        let requestHistory = [];
        let currentHistoryIndex = null;
        const MAX_HISTORY_ITEMS = 1000; // Keep last 1000 items
        
        // Load history from localStorage on startup
        function loadHistory() {
            const saved = localStorage.getItem('mcp-request-history');
            if (saved) {
                try {
                    requestHistory = JSON.parse(saved);
                } catch (e) {
                    console.error('Failed to load history:', e);
                    requestHistory = [];
                }
            }
        }
        
        // Save history to localStorage
        function saveHistory() {
            let saved = false;
            let attempts = 0;
            const maxAttempts = 20; // Prevent infinite loop
            
            while (!saved && attempts < maxAttempts && requestHistory.length > 0) {
                try {
                    localStorage.setItem('mcp-request-history', JSON.stringify(requestHistory));
                    saved = true;
                } catch (e) {
                    // Check if it's a quota exceeded error
                    if (e.name === 'QuotaExceededError' || e.code === 22) {
                        console.warn('localStorage quota exceeded, removing oldest history items...');
                        
                        // Remove 10% of oldest items (at least 1)
                        const itemsToRemove = Math.max(1, Math.floor(requestHistory.length * 0.1));
                        requestHistory = requestHistory.slice(0, requestHistory.length - itemsToRemove);
                        
                        attempts++;
                    } else {
                        // Some other error, log and stop
                        console.error('Failed to save history:', e);
                        break;
                    }
                }
            }
            
            if (!saved && requestHistory.length === 0) {
                console.error('Could not save history even after removing all items');
            } else if (saved && attempts > 0) {
                console.log(`History saved after removing ${attempts} batch(es) of old items`);
            }
        }
        
        // Function to highlight JSON syntax with colors
        function syntaxHighlightJson(json) {
            // Custom replacer function to handle nested JSON strings
            const replacer = (key, value) => {
                // Check if this is a text field that might contain JSON
                if (key === 'text' && typeof value === 'string') {
                    // Try to detect if it's a JSON string
                    const trimmed = value.trim();
                    if ((trimmed.startsWith('{') && trimmed.endsWith('}')) || 
                        (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
                        try {
                            // Try to parse the JSON string and return it directly
                            return JSON.parse(value);
                        } catch (e) {
                            // Not valid JSON, return as is
                            return value;
                        }
                    }
                }
                return value;
            };
            
            // Use more space for indentation to make it easier to read
            const jsonStr = JSON.stringify(json, replacer, 4);
            
            // A more direct approach for syntax highlighting
            let result = '';
            let inString = false;
            let isKey = false;
            let currentStr = '';
            let lastChar = '';
            
            // Process each character individually to maintain proper context
            for (let i = 0; i < jsonStr.length; i++) {
                const char = jsonStr[i];
                
                // Handle string delimiters
                if (char === '"' && lastChar !== '\\') {
                    if (!inString) {
                        // Start of a new string
                        inString = true;
                        currentStr = char;
                        
                        // Check if this might be a key by looking ahead for a colon
                        isKey = false;
                        for (let j = i + 1; j < jsonStr.length; j++) {
                            if (jsonStr[j] === '"' && jsonStr[j-1] !== '\\') {
                                // End of string found, now look for colon
                                for (let k = j + 1; k < jsonStr.length; k++) {
                                    if (jsonStr[k] === ':') {
                                        isKey = true;
                                        break;
                                    } else if (jsonStr[k] !== ' ' && jsonStr[k] !== '\t' && jsonStr[k] !== '\n') {
                                        break;
                                    }
                                }
                                break;
                            }
                        }
                    } else {
                        // End of a string
                        currentStr += char;
                        inString = false;
                        
                        // Apply the appropriate class for string formatting
                        if (isKey) {
                            result += '<span class="json-key">' + escapeHtml(currentStr) + '</span>';
                        } else {
                            result += '<span class="json-string">' + escapeHtml(currentStr) + '</span>';
                        }
                        currentStr = '';
                    }
                } 
                else if (inString) {
                    // Inside a string, collect characters
                    currentStr += char;
                }
                else if (char === ':') {
                    result += '<span class="json-colon">:</span>';
                }
                else if (char === ',') {
                    result += '<span class="json-comma">,</span>';
                }
                else if (char === '{' || char === '}' || char === '[' || char === ']') {
                    result += '<span class="json-bracket">' + char + '</span>';
                }
                else if (char === 't' && jsonStr.substring(i, i+4) === 'true') {
                    result += '<span class="json-boolean-true">true</span>';
                    i += 3; // Skip the rest of "true"
                }
                else if (char === 'f' && jsonStr.substring(i, i+5) === 'false') {
                    result += '<span class="json-boolean-false">false</span>';
                    i += 4; // Skip the rest of "false"
                }
                else if (char === 'n' && jsonStr.substring(i, i+4) === 'null') {
                    result += '<span class="json-null">null</span>';
                    i += 3; // Skip the rest of "null"
                }
                else if (/[0-9]/.test(char) || char === '-') {
                    // Start of a number
                    let numberStr = char;
                    for (let j = i + 1; j < jsonStr.length; j++) {
                        if (/[0-9.eE+-]/.test(jsonStr[j])) {
                            numberStr += jsonStr[j];
                            i++;
                        } else {
                            break;
                        }
                    }
                    result += '<span class="json-number">' + numberStr + '</span>';
                }
                else {
                    // Whitespace and other characters
                    result += char;
                }
                
                lastChar = char;
            }
            
            return result;
        }
        
        // Helper function to escape HTML entities
        function escapeHtml(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                // Replace literal \n with actual line breaks for display
                .replace(/\\n/g, '<br>');
        }
        
        // Function to display response based on current toggle state
        function displayResponse() {
            if (!currentResponseRaw && !currentResponseError) {
                responseViewer.innerHTML = '<span class="json-null">No response yet.</span>';
                return;
            }
            
            if (rawViewToggle.checked) {
                // Show raw response
                responseViewer.textContent = currentResponseRaw || '';
            } else {
                // Show parsed response
                if (currentResponseError) {
                    responseViewer.innerHTML = `<div style="color: #d00; font-weight: bold;">⚠️ Parse Error:</div><div style="color: #d00; margin-top: 8px;">${escapeHtml(currentResponseError)}</div>`;
                } else if (currentResponseParsed) {
                    responseViewer.innerHTML = syntaxHighlightJson(currentResponseParsed);
                } else {
                    responseViewer.innerHTML = '<span class="json-null">No response yet.</span>';
                }
            }
        }
        
        // Toggle handler
        rawViewToggle.addEventListener('change', displayResponse);
        
        // JSON Editor instance
        let jsonSchemaEditor = null;
        let currentActiveTab = 'editRequest';
        
        // Tab switching functionality
        function switchTab(tabName) {
            console.log('Switching to tab:', tabName);
            
            // Update tab active states
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Activate selected tab
            const selectedTab = document.querySelector(`[data-tab="${tabName}"]`);
            const selectedContent = document.getElementById(`${tabName}Content`);
            
            if (selectedTab && selectedContent) {
                selectedTab.classList.add('active');
                selectedContent.classList.add('active');
                currentActiveTab = tabName;
                
                // Update content based on tab
                if (tabName === 'editRequest') {
                    updateSchemaForm();
                } else if (tabName === 'schema') {
                    updateSchemaView();
                }
            } else {
                console.error('Tab or content not found:', tabName, selectedTab, selectedContent);
            }
        }
        
        // Add click handlers to tabs
        editRequestTab.addEventListener('click', () => switchTab('editRequest'));
        schemaTab.addEventListener('click', () => switchTab('schema'));
        rawTab.addEventListener('click', () => switchTab('raw'));
        
        // Function to get the current schema for the method
        function getCurrentSchema() {
            if (!currentMethod) return null;
            
            // Check if this is a history item first
            if (currentFlow === 'history-flow') {
                const flow = flows[currentFlow];
                const method = flow && flow.methods[currentMethod];
                if (method && method.historyItem && method.historyItem.schema) {
                    return method.historyItem.schema;
                }
            }
            
            // Check if this is a tool method (either tools/call or tool:*)
            let toolName = null;
            
            // Check if method name is tool:something
            if (currentMethod.startsWith('tool:')) {
                toolName = currentMethod.substring(5); // Remove 'tool:' prefix
            }
            // Or if it's tools/call, extract from the request
            else if (currentMethod === 'tools/call' && jsonEditor.value) {
                try {
                    const request = JSON.parse(jsonEditor.value);
                    if (request.params && request.params.name) {
                        toolName = request.params.name;
                    }
                } catch (e) {
                    // Ignore parse errors
                }
            }
            
            // If we identified a tool, try to show its schema
            if (toolName) {
                const tool = toolSchemas.get(toolName);
                
                if (tool) {
                    return {
                        method: currentMethod.startsWith('tool:') ? currentMethod : `tools/call → ${toolName}`,
                        description: tool.description,
                        inputSchema: tool.inputSchema,
                        toolName: toolName
                    };
                } else {
                    return null;
                }
            }
            
            // For all other methods, get schema from method state if available
            const key = `${currentFlow}:${currentMethod}`;
            const state = methodState.get(key);
            
            // Check if we have a stored schema for this method
            if (state && state.methodSchema) {
                return {
                    method: currentMethod,
                    description: state.methodSchema.description,
                    inputSchema: state.methodSchema.inputSchema
                };
            } else if (methodSchemas[currentMethod]) {
                // Use predefined schema
                const schema = methodSchemas[currentMethod];
                return {
                    method: currentMethod,
                    description: schema.description,
                    inputSchema: schema.inputSchema
                };
            }
            
            return null;
        }
        
        // Function to update the schema view tab
        function updateSchemaView() {
            const schema = getCurrentSchema();
            
            if (schema) {
                schemaViewer.innerHTML = syntaxHighlightJson(schema);
            } else {
                // Show basic info from method definition
                const flow = flows[currentFlow];
                const method = flow && flow.methods[currentMethod];
                
                if (method) {
                    const schemaData = {
                        method: currentMethod,
                        description: method.description || 'No description available',
                        note: 'Complete schema not available',
                        defaultRequest: method.defaultRequest
                    };
                    schemaViewer.innerHTML = syntaxHighlightJson(schemaData);
                } else {
                    schemaViewer.innerHTML = '<span style="color: #666;">No schema information available for this method.</span>';
                }
            }
        }
        
        // Function to update the schema form editor
        function updateSchemaForm() {
            const schema = getCurrentSchema();
            
            // Destroy existing editor if any
            if (jsonSchemaEditor) {
                jsonSchemaEditor.destroy();
                jsonSchemaEditor = null;
                schemaFormEditor.innerHTML = '';
            }
            
            if (schema && schema.inputSchema) {
                // Hide no schema message
                noSchemaMessage.style.display = 'none';
                schemaFormEditor.style.display = 'block';
                
                // Clear the editor and add title if available
                schemaFormEditor.innerHTML = '';
                
                // Add the schema title at the top if available
                if (schema.inputSchema.title) {
                    const titleElement = document.createElement('h4');
                    titleElement.textContent = schema.inputSchema.title;
                    titleElement.style.margin = '0 0 10px 0';
                    titleElement.style.color = '#0088cc';
                    titleElement.style.fontSize = '1.1em';
                    schemaFormEditor.appendChild(titleElement);
                }
                
                // Create a container for the form
                const formContainer = document.createElement('div');
                schemaFormEditor.appendChild(formContainer);
                
                // Clone the schema for modification
                const modifiedSchema = JSON.parse(JSON.stringify(schema.inputSchema));
                
                // Store array titles for later injection
                const arrayTitles = {};
                if (modifiedSchema.properties) {
                    Object.keys(modifiedSchema.properties).forEach(key => {
                        const prop = modifiedSchema.properties[key];
                        if (prop.type === 'array' && prop.title) {
                            arrayTitles[key] = prop.title;
                        }
                        // Try converting description to infoText for all fields
                        if (prop.description && !prop.infoText) {
                            prop.infoText = prop.description;
                            // Optionally remove description to see if infoText works as tooltip
                            // delete prop.description;
                        }
                    });
                }
                
                // Create the JSON editor with the schema
                const editorOptions = {
                    schema: modifiedSchema,
                    theme: 'html',
                    disable_edit_json: true,
                    disable_properties: true,
                    disable_collapse: true,
                    no_additional_properties: true,
                    required_by_default: false,
                    show_errors: 'always',
                    // Try to use infoText for tooltips
                    use_default_values: true,
                    compact: true,
                    input_width: '100%',
                    show_opt_in: false  // Show all optional fields by default
                };
                
                // Get current value from JSON editor if available
                let startValue = {};
                try {
                    const currentRequest = JSON.parse(jsonEditor.value);
                    if (currentRequest.params) {
                        if (schema.toolName && currentRequest.params.arguments) {
                            // For tools/call, use the arguments
                            startValue = currentRequest.params.arguments;
                        } else {
                            // For other methods, use params directly
                            startValue = currentRequest.params;
                        }
                    }
                } catch (e) {
                    // Use defaults if parse fails
                }
                
                // Ensure all properties are initialized with their defaults or empty values
                if (modifiedSchema.properties) {
                    Object.keys(modifiedSchema.properties).forEach(key => {
                        const prop = modifiedSchema.properties[key];
                        if (!startValue.hasOwnProperty(key)) {
                            if (prop.type === 'array') {
                                startValue[key] = [];
                            } else if (prop.type === 'string') {
                                startValue[key] = prop.default !== undefined ? prop.default : '';
                            } else if (prop.type === 'number') {
                                startValue[key] = prop.default !== undefined ? prop.default : 0;
                            } else if (prop.type === 'boolean') {
                                startValue[key] = prop.default !== undefined ? prop.default : false;
                            } else if (prop.type === 'object') {
                                startValue[key] = prop.default !== undefined ? prop.default : {};
                            } else if (prop.anyOf || prop.oneOf) {
                                // For anyOf/oneOf, use the default if specified
                                startValue[key] = prop.default !== undefined ? prop.default : null;
                            }
                        }
                    });
                }
                
                try {
                    jsonSchemaEditor = new JSONEditor(formContainer, editorOptions);
                    
                    // Set initial value after a small delay to ensure editor is ready
                    setTimeout(() => {
                        if (jsonSchemaEditor) {
                            try {
                                jsonSchemaEditor.setValue(startValue);
                            } catch (e) {
                                console.warn('Could not set initial value:', e);
                            }
                            
                            // Inject array titles and fix layout
                            Object.keys(arrayTitles).forEach(key => {
                                const container = formContainer.querySelector(`[data-schemapath="root.${key}"]`);
                                if (container) {
                                    // Find the description element
                                    const description = container.querySelector('p.help-block, p');
                                    if (description && description.textContent.trim()) {
                                        // Check if there's already a je-header with the title
                                        const existingHeader = container.querySelector('.je-header > span:not(button):not(.je-header-button-holder)');
                                        
                                        // Create info icon for array description
                                        const infoIcon = document.createElement('span');
                                        infoIcon.className = 'schema-field-info';
                                        infoIcon.textContent = 'i';
                                        
                                        // Store tooltip text
                                        const tooltipText = description.textContent.trim();
                                            
                                            // Create tooltip on hover
                                            let tooltip = null;
                                            infoIcon.addEventListener('mouseenter', (e) => {
                                                // Create tooltip element
                                                tooltip = document.createElement('div');
                                                tooltip.className = 'schema-field-tooltip';
                                                // Convert newlines to <br/>
                                                tooltip.innerHTML = tooltipText.replace(/\n/g, '<br/>');
                                                tooltip.style.display = 'block';
                                                document.body.appendChild(tooltip);
                                                
                                                // Position tooltip
                                                const rect = infoIcon.getBoundingClientRect();
                                                tooltip.style.left = (rect.left + rect.width/2 - 162) + 'px'; // Center it (325/2 = 162)
                                                tooltip.style.top = (rect.top - tooltip.offsetHeight - 5) + 'px';
                                            });
                                            
                                            infoIcon.addEventListener('mouseleave', () => {
                                                if (tooltip) {
                                                    tooltip.remove();
                                                    tooltip = null;
                                                }
                                            });
                                            
                                        // Add info icon to the appropriate element
                                        if (existingHeader && existingHeader.textContent === arrayTitles[key]) {
                                            // Add to existing header
                                            if (!existingHeader.querySelector('.schema-field-info')) {
                                                existingHeader.appendChild(infoIcon);
                                            }
                                        } else {
                                            // Create a new label if header doesn't exist
                                            const label = document.createElement('label');
                                            label.style.cssText = 'display: block !important; font-size: 0.85em !important; font-weight: 500 !important; margin-bottom: 4px !important; padding-left: 10px !important; padding-right: 10px !important;';
                                            label.textContent = arrayTitles[key];
                                            label.className = 'array-field-label';
                                            label.appendChild(infoIcon);
                                            description.parentNode.insertBefore(label, description);
                                        }
                                        
                                        // Keep the description visible
                                        // description.style.display = 'none';
                                    }
                                    
                                    // Fix delete button visibility for empty arrays
                                    const arrayValue = jsonSchemaEditor.getEditor(`root.${key}`);
                                    if (arrayValue && arrayValue.getValue) {
                                        const value = arrayValue.getValue();
                                        if (!value || value.length === 0) {
                                            // Hide all delete-related buttons when array is empty
                                            const deleteButtons = container.querySelectorAll('button[title*="Delete"], button[title*="delete"], button[title*="Last"], button[title*="All"], .json-editor-btn-delete, .json-editor-btn-deleteall, .json-editor-btn-deletelast');
                                            deleteButtons.forEach(btn => {
                                                btn.style.display = 'none';
                                            });
                                        }
                                    }
                                }
                            });
                            
                            
                            // DISABLED - Convert descriptions to tooltips
                            // Keeping descriptions visible in the fields for better UX
                            /*
                            const convertDescriptionsToTooltips = () => {
                                // Find all description paragraphs
                                const descriptions = formContainer.querySelectorAll('p.je-form-input-label[id$="-description"]');
                                
                                descriptions.forEach(desc => {
                                    // Get the field name from the ID
                                    const fieldMatch = desc.id.match(/root\[([^\]]+)\]-description/);
                                    if (!fieldMatch) return;
                                    
                                    const fieldName = fieldMatch[1];
                                    
                                    // Find the corresponding label
                                    const label = formContainer.querySelector(`label[for="root[${fieldName}]"]`);
                                    if (label && !label.querySelector('.schema-field-info')) {
                                        // Create info icon
                                        const infoIcon = document.createElement('span');
                                        infoIcon.className = 'schema-field-info';
                                        infoIcon.textContent = 'i';
                                        
                                        // Store tooltip text
                                        const tooltipText = desc.textContent.trim();
                                        
                                        // Create tooltip on hover
                                        let tooltip = null;
                                        infoIcon.addEventListener('mouseenter', (e) => {
                                            // Create tooltip element
                                            tooltip = document.createElement('div');
                                            tooltip.className = 'schema-field-tooltip';
                                            // Convert newlines to <br/>
                                            tooltip.innerHTML = tooltipText.replace(/\n/g, '<br/>');
                                            tooltip.style.display = 'block';
                                            document.body.appendChild(tooltip);
                                            
                                            // Position tooltip
                                            const rect = infoIcon.getBoundingClientRect();
                                            tooltip.style.left = (rect.left + rect.width/2 - 162) + 'px'; // Center it (325/2 = 162)
                                            tooltip.style.top = (rect.top - tooltip.offsetHeight - 5) + 'px';
                                        });
                                        
                                        infoIcon.addEventListener('mouseleave', () => {
                                            if (tooltip) {
                                                tooltip.remove();
                                                tooltip = null;
                                            }
                                        });
                                        
                                        // Add icon to label
                                        label.appendChild(infoIcon);
                                        
                                        // Hide the description
                                        desc.style.display = 'none';
                                    }
                                });
                                
                                // Also force array font sizes
                                const arrayLabels = formContainer.querySelectorAll('.array-field-label, [data-schemapath*="nodes"] > label');
                                arrayLabels.forEach(label => {
                                    if (label.style.fontSize !== '0.85em') {
                                        label.style.setProperty('font-size', '0.85em', 'important');
                                    }
                                });
                            };
                            
                            // Run it after a small delay
                            setTimeout(convertDescriptionsToTooltips, 300);
                            */
                        }
                    }, 100);
                    
                    // Watch for changes and update the raw JSON
                    jsonSchemaEditor.on('change', () => {
                        if (currentActiveTab === 'editRequest') {
                            updateRawFromForm();
                            
                            // Update delete button visibility for arrays
                            Object.keys(arrayTitles).forEach(key => {
                                const container = formContainer.querySelector(`[data-schemapath="root.${key}"]`);
                                if (container) {
                                    const arrayValue = jsonSchemaEditor.getEditor(`root.${key}`);
                                    if (arrayValue && arrayValue.getValue) {
                                        const value = arrayValue.getValue();
                                        const deleteButtons = container.querySelectorAll('button[title*="Delete"], button[title*="delete"], button[title*="Last"], button[title*="All"], .json-editor-btn-delete, .json-editor-btn-deleteall, .json-editor-btn-deletelast');
                                        deleteButtons.forEach(btn => {
                                            btn.style.display = (!value || value.length === 0) ? 'none' : 'inline-block';
                                        });
                                    }
                                }
                            });
                        }
                    });
                } catch (e) {
                    console.error('Error creating JSON Editor:', e);
                    noSchemaMessage.style.display = 'block';
                    schemaFormEditor.style.display = 'none';
                }
            } else {
                // Show no schema message
                noSchemaMessage.style.display = 'block';
                schemaFormEditor.style.display = 'none';
            }
        }
        
        // Function to update raw JSON from form
        function updateRawFromForm() {
            if (!jsonSchemaEditor) return;
            
            try {
                const formData = jsonSchemaEditor.getValue();
                const currentRequest = JSON.parse(jsonEditor.value);
                
                // Update the params based on method type
                const schema = getCurrentSchema();
                if (schema && schema.toolName) {
                    // For tools/call, update arguments
                    currentRequest.params = currentRequest.params || {};
                    currentRequest.params.arguments = formData;
                } else {
                    // For other methods, update params directly
                    currentRequest.params = formData;
                }
                
                jsonEditor.value = JSON.stringify(currentRequest, null, 4);
                saveCurrentRequest();
            } catch (e) {
                console.error('Error updating raw JSON from form:', e);
            }
        }
        
        // State storage for method requests and responses
        const methodState = new Map();
        const toolSchemas = new Map();  // Store tool schemas from tools/list
        let currentFlow = 'initialize-flow';
        let currentMethod = null;
        
        // Predefined schemas for MCP standard methods
        const methodSchemas = {
            'initialize': {
                description: 'Initialize the MCP connection and discover server capabilities',
                inputSchema: {
                    type: 'object',
                    properties: {
                        protocolVersion: {
                            type: 'string',
                            description: 'MCP protocol version',
                            default: '2024-11-05'
                        },
                        capabilities: {
                            type: 'object',
                            description: 'Client capabilities'
                        },
                        clientInfo: {
                            type: 'object',
                            properties: {
                                name: { type: 'string', description: 'Client name' },
                                version: { type: 'string', description: 'Client version' },
                                description: { type: 'string', description: 'Client description' }
                            }
                        }
                    },
                    required: ['protocolVersion', 'capabilities', 'clientInfo']
                }
            },
            'ping': {
                description: 'Ping the server to check connectivity',
                inputSchema: {
                    type: 'object',
                    properties: {},
                    additionalProperties: false
                }
            },
            'tools/list': {
                description: 'List all available tools with their schemas',
                inputSchema: {
                    type: 'object',
                    properties: {
                        cursor: {
                            type: 'string',
                            description: 'Pagination cursor from previous response'
                        }
                    },
                    additionalProperties: false
                }
            },
            'tools/call': {
                description: 'Execute a tool with the specified arguments',
                inputSchema: {
                    type: 'object',
                    properties: {
                        name: {
                            type: 'string',
                            description: 'Name of the tool to execute'
                        },
                        arguments: {
                            type: 'object',
                            description: 'Tool-specific arguments (see tool schema for details)'
                        }
                    },
                    required: ['name']
                }
            },
            'resources/list': {
                description: 'List available resources',
                inputSchema: {
                    type: 'object',
                    properties: {
                        cursor: {
                            type: 'string',
                            description: 'Pagination cursor from previous response'
                        }
                    }
                }
            },
            'resources/read': {
                description: 'Read a specific resource by URI',
                inputSchema: {
                    type: 'object',
                    properties: {
                        uri: {
                            type: 'string',
                            description: 'Resource URI (e.g., "nd://contexts")'
                        }
                    },
                    required: ['uri']
                }
            },
            'prompts/list': {
                description: 'List available prompts',
                inputSchema: {
                    type: 'object',
                    properties: {
                        cursor: {
                            type: 'string',
                            description: 'Pagination cursor'
                        }
                    }
                }
            },
            'prompts/get': {
                description: 'Get a specific prompt by name',
                inputSchema: {
                    type: 'object',
                    properties: {
                        name: {
                            type: 'string',
                            description: 'Prompt name'
                        },
                        arguments: {
                            type: 'object',
                            description: 'Prompt arguments'
                        }
                    },
                    required: ['name']
                }
            },
            'completion/complete': {
                description: 'Request text completion',
                inputSchema: {
                    type: 'object',
                    properties: {
                        ref: {
                            type: 'object',
                            properties: {
                                type: { type: 'string', enum: ['resource'] },
                                uri: { type: 'string' }
                            }
                        },
                        argument: {
                            type: 'object',
                            properties: {
                                name: { type: 'string' },
                                value: { type: 'string' }
                            }
                        }
                    }
                }
            }
        };
        
        // Method definitions by flow
        const flows = {
            'initialize-flow': {
                name: 'Initialize',
                methods: {
                    'initialize': {
                        name: 'initialize',
                        description: 'Get information about available resources and methods',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'initialize',
                            params: {
                                protocolVersion: '2024-11-05',
                                capabilities: {
                                    textDocument: {
                                        synchronization: {
                                            incremental: true
                                        }
                                    },
                                    completion: {
                                        contextSupport: true
                                    }
                                },
                                clientInfo: {
                                    name: 'netdata-mcp-test',
                                    version: '1.0.0',
                                    description: 'Netdata MCP Protocol Test Client'
                                }
                            },
                            id: 1
                        }
                    }
                }
            },
            'tools-flow': {
                name: 'Tools',
                methods: {
                    'tools/list': {
                        name: 'tools/list',
                        description: 'Get list of available tools with their schemas',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'tools/list',
                            params: {},
                            id: 1
                        }
                    },
                    'tools/call': {
                        name: 'tools/call',
                        description: 'Execute a tool with parameters',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'tools/call',
                            params: {
                                name: 'contexts',
                                arguments: {
                                    like: 'system.*'
                                }
                            },
                            id: 1
                        }
                    }
                }
            },
            'resources-flow': {
                name: 'Resources',
                methods: {
                    'resources/list': {
                        name: 'resources/list',
                        description: 'Get list of available resources',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'resources/list',
                            params: {
                                // Optional pagination cursor
                                // cursor: "pagination_token"
                            },
                            id: 1
                        }
                    },
                    'resources/read': {
                        name: 'resources/read',
                        description: 'Read a specific resource by URI',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'resources/read',
                            params: {
                                uri: 'nd://contexts'
                            },
                            id: 1
                        }
                    },
                    'resources/templates/list': {
                        name: 'resources/templates/list',
                        description: 'Get list of resource templates for URI construction',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'resources/templates/list',
                            params: {
                                // Optional pagination cursor
                                // cursor: "pagination_token"
                            },
                            id: 1
                        }
                    },
                    'resources/subscribe': {
                        name: 'resources/subscribe',
                        description: 'Subscribe to changes in a resource',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'resources/subscribe',
                            params: {
                                uri: 'nd://contexts'
                            },
                            id: 1
                        }
                    },
                    'resources/unsubscribe': {
                        name: 'resources/unsubscribe',
                        description: 'Unsubscribe from a resource',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'resources/unsubscribe',
                            params: {
                                uri: 'nd://contexts'
                            },
                            id: 1
                        }
                    }
                }
            },
            'prompts-flow': {
                name: 'Prompts',
                methods: {
                    'prompts/list': {
                        name: 'prompts/list',
                        description: 'Get list of available prompts',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'prompts/list',
                            params: {},
                            id: 1
                        }
                    },
                    'prompts/get': {
                        name: 'prompts/get',
                        description: 'Get a specific prompt',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'prompts/get',
                            params: {
                                name: 'analyze_metrics'
                            },
                            id: 1
                        }
                    },
                }
            },
            'ping-flow': {
                name: 'Ping',
                methods: {
                    'ping': {
                        name: 'ping',
                        description: 'Simple health check to ensure server is responsive',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'ping',
                            params: {},
                            id: 1
                        }
                    }
                }
            },
            'logging-flow': {
                name: 'Logging',
                methods: {
                    'logging/setLevel': {
                        name: 'logging/setLevel',
                        description: 'Set the logging level for the server',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'logging/setLevel',
                            params: {
                                level: 'info'
                            },
                            id: 1
                        }
                    }
                }
            },
            'completion-flow': {
                name: 'Completion',
                methods: {
                    'completion/complete': {
                        name: 'completion/complete',
                        description: 'Request completions for an argument',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'completion/complete',
                            params: {
                                argument: {
                                    name: 'test',
                                    value: 'test'
                                },
                                ref: {
                                    type: 'ref/prompt',
                                    name: 'test-prompt'
                                }
                            },
                            id: 1
                        }
                    }
                }
            },
            'history-flow': {
                name: 'History',
                methods: {} // Will be populated dynamically with history items
            }
            // End of standard MCP flows
        };
        
        // Add a request/response to history
        function addToHistory(method, request, response, responseRaw, error) {
            // Get the current schema before storing in history
            const currentSchema = getCurrentSchema();
            
            const historyItem = {
                id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                timestamp: new Date().toISOString(),
                method: method,
                request: request,
                response: response,
                responseRaw: responseRaw,
                error: error,
                schema: currentSchema // Store the schema with the history item
            };
            
            // Add to beginning of array (newest first)
            requestHistory.unshift(historyItem);
            
            // Limit history size
            if (requestHistory.length > MAX_HISTORY_ITEMS) {
                requestHistory = requestHistory.slice(0, MAX_HISTORY_ITEMS);
            }
            
            // Save to localStorage
            const originalLength = requestHistory.length;
            saveHistory();
            
            // Update history flow if currently viewing it or if items were removed
            if (currentFlow === 'history-flow' || requestHistory.length < originalLength) {
                loadHistoryMethods();
            }
        }
        
        // Load history items as methods in the history flow
        function loadHistoryMethods() {
            flows['history-flow'].methods = {};
            
            requestHistory.forEach((item, index) => {
                const date = new Date(item.timestamp);
                const timeStr = date.toLocaleTimeString();
                const dateStr = date.toLocaleDateString();
                
                flows['history-flow'].methods[item.id] = {
                    name: `${item.method} - ${timeStr}`,
                    description: `${dateStr} - ${item.error ? 'Failed' : 'Success'}`,
                    dynamic: true,
                    isHistory: true,
                    hasError: !!item.error,
                    historyItem: item,
                    defaultRequest: item.request
                };
            });
        }
        
        // Initialize UI
        function initializeUI() {
            // Populate flow items
            flowsContainer.innerHTML = '';
            Object.keys(flows).forEach(flowId => {
                const flow = flows[flowId];
                const flowElement = document.createElement('div');
                flowElement.className = `flow-item ${flowId === currentFlow ? 'active' : ''}`;
                flowElement.dataset.flow = flowId;
                flowElement.textContent = flow.name;
                flowElement.addEventListener('click', () => selectFlow(flowId));
                flowsContainer.appendChild(flowElement);
            });
            
            // Load methods for current flow
            loadMethodsForFlow(currentFlow);
        }
        
        // Clear history
        function clearHistory() {
            if (confirm('Are you sure you want to clear all history? This cannot be undone.')) {
                requestHistory = [];
                saveHistory();
                if (currentFlow === 'history-flow') {
                    loadHistoryMethods();
                    loadMethodsForFlow('history-flow');
                }
            }
        }
        
        // Load methods for a specific flow
        function loadMethodsForFlow(flowId) {
            methodsContainer.innerHTML = '';
            const flow = flows[flowId];
            
            if (!flow) return;
            
            // Update header based on flow
            if (flowId === 'history-flow') {
                methodsHeader.innerHTML = 'Methods <button onclick="clearHistory()" style="float: right; font-size: 12px; padding: 4px 8px;">Clear History</button>';
                loadHistoryMethods();
            } else {
                methodsHeader.textContent = 'Methods';
            }
            
            Object.keys(flow.methods).forEach(methodId => {
                const method = flow.methods[methodId];
                const methodElement = document.createElement('div');
                
                // Determine the class based on method type
                let className = 'method-item';
                if (method.isHistory) {
                    className += ' history';
                    if (method.hasError) {
                        className += ' error';
                    }
                } else if (method.dynamic) {
                    className += ' dynamic';
                }
                
                methodElement.className = className;
                methodElement.dataset.method = methodId;
                methodElement.dataset.flow = flowId;
                
                const methodName = document.createElement('div');
                methodName.textContent = method.name;
                methodName.style.fontWeight = 'bold';
                
                const methodDesc = document.createElement('div');
                methodDesc.style.fontSize = '0.9em';
                methodDesc.style.color = '#666';
                
                // For tools, check if we have inputSchema.title to display instead of description
                let displayText = method.description;
                let tooltipText = null;
                
                if (method.toolData && method.toolData.inputSchema && method.toolData.inputSchema.title) {
                    // Use inputSchema.title as main text, description as tooltip
                    displayText = method.toolData.inputSchema.title;
                    tooltipText = method.description;
                } else if (flowId === 'tools-flow' && methodId.startsWith('tool:')) {
                    // For dynamic tool methods, try to get the schema from toolSchemas
                    const toolName = methodId.substring(5); // Remove 'tool:' prefix
                    const tool = toolSchemas.get(toolName);
                    if (tool && tool.inputSchema && tool.inputSchema.title) {
                        displayText = tool.inputSchema.title;
                        tooltipText = tool.description;
                    }
                }
                
                methodDesc.textContent = displayText;
                
                // Add tooltip to the entire method element if we have description
                if (tooltipText) {
                    methodElement.style.position = 'relative';
                    methodElement.classList.add('tooltip');
                    
                    // Create tooltip text element
                    const tooltipTextElement = document.createElement('span');
                    tooltipTextElement.className = 'tooltiptext';
                    // Convert newlines to <br/> after escaping HTML
                    tooltipTextElement.innerHTML = escapeHtml(tooltipText).replace(/\n/g, '<br/>');
                    
                    methodElement.appendChild(tooltipTextElement);
                    
                    // Use event listeners to position the fixed tooltip
                    methodElement.addEventListener('mouseenter', function(e) {
                        const rect = this.getBoundingClientRect();
                        tooltipTextElement.style.left = (rect.right + 10) + 'px';
                        tooltipTextElement.style.top = (rect.top + rect.height/2) + 'px';
                        tooltipTextElement.style.transform = 'translateY(-50%)';
                    });
                    
                    // Add info indicator to description
                    const infoIndicator = document.createElement('span');
                    infoIndicator.textContent = ' ⓘ';
                    infoIndicator.style.fontSize = '0.8em';
                    infoIndicator.style.opacity = '0.7';
                    methodDesc.appendChild(infoIndicator);
                }
                
                methodElement.appendChild(methodName);
                methodElement.appendChild(methodDesc);
                
                methodElement.addEventListener('click', () => selectMethod(flowId, methodId));
                methodsContainer.appendChild(methodElement);
            });
            
            // Select the first method by default, or restore the previously selected method
            const savedMethod = localStorage.getItem(`selected-method-${flowId}`);
            if (savedMethod && flows[flowId].methods[savedMethod]) {
                selectMethod(flowId, savedMethod);
            } else {
                const firstMethod = Object.keys(flow.methods)[0];
                selectMethod(flowId, firstMethod);
            }
        }
        
        // Select a flow
        function selectFlow(flowId) {
            // Update UI
            document.querySelectorAll('.flow-item').forEach(item => {
                item.classList.toggle('active', item.dataset.flow === flowId);
            });
            
            // Save current request if a method is selected
            if (currentMethod) {
                saveCurrentRequest();
            }
            
            // Update state
            currentFlow = flowId;
            localStorage.setItem('selected-flow', flowId);
            
            // Load methods for this flow
            loadMethodsForFlow(flowId);
        }
        
        // Select a method
        function selectMethod(flowId, methodId) {
            // Save current request if a method is already selected
            if (currentMethod) {
                saveCurrentRequest();
            }
            
            // Update UI
            document.querySelectorAll('.method-item').forEach(item => {
                item.classList.toggle('active', item.dataset.method === methodId);
            });
            
            // Update state
            currentFlow = flowId;
            currentMethod = methodId;
            localStorage.setItem('selected-flow', flowId);
            localStorage.setItem(`selected-method-${flowId}`, methodId);
            
            // Load saved or default request for this method
            loadRequestForMethod(flowId, methodId);
            
            // Load saved response for this method if exists
            loadResponseForMethod(flowId, methodId);
            
            // Update current tab content
            if (currentActiveTab === 'editRequest') {
                updateSchemaForm();
            } else if (currentActiveTab === 'schema') {
                updateSchemaView();
            }
        }
        
        // Save the current request in the editor
        function saveCurrentRequest() {
            if (!currentFlow || !currentMethod) return;
            
            try {
                const requestObj = JSON.parse(jsonEditor.value);
                const key = `${currentFlow}:${currentMethod}`;
                
                if (!methodState.has(key)) {
                    methodState.set(key, {});
                }
                
                methodState.get(key).request = requestObj;
                localStorage.setItem(`request:${key}`, jsonEditor.value);
            } catch (error) {
                console.error('Failed to save request:', error);
            }
        }
        
        // Load a request for the selected method
        function loadRequestForMethod(flowId, methodId) {
            const key = `${flowId}:${methodId}`;
            const defaultRequest = flows[flowId].methods[methodId].defaultRequest;
            
            // Try to load from session storage
            let savedRequest = localStorage.getItem(`request:${key}`);
            
            if (savedRequest) {
                jsonEditor.value = savedRequest;
            } else if (methodState.has(key) && methodState.get(key).request) {
                jsonEditor.value = JSON.stringify(methodState.get(key).request, null, 4);
            } else {
                // Use default
                jsonEditor.value = JSON.stringify(defaultRequest, null, 4);
            }
        }
        
        // Load a saved response for the selected method
        function loadResponseForMethod(flowId, methodId) {
            const key = `${flowId}:${methodId}`;
            
            // Special handling for history items
            if (flowId === 'history-flow' && flows[flowId].methods[methodId]) {
                const historyItem = flows[flowId].methods[methodId].historyItem;
                if (historyItem) {
                    currentResponseRaw = historyItem.responseRaw || null;
                    currentResponseParsed = historyItem.response || null;
                    currentResponseError = historyItem.error || null;
                    
                    // Display response based on toggle state
                    displayResponse();
                    
                    requestData.textContent = 'Request: ' + JSON.stringify(historyItem.request, null, 2);
                    
                    // Show the timestamp in the comm log
                    const date = new Date(historyItem.timestamp);
                    commLog.innerHTML = `[${date.toLocaleTimeString()}.${String(date.getMilliseconds()).padStart(3, '0')}] Historical request\n`;
                    return;
                }
            }
            
            if (methodState.has(key)) {
                const state = methodState.get(key);
                
                // Update current response data
                currentResponseRaw = state.responseRaw || null;
                currentResponseParsed = state.response || null;
                currentResponseError = state.responseError || null;
                
                // Display response based on toggle state
                displayResponse();
                
                if (state.requestSent) {
                    requestData.textContent = 'Request: ' + JSON.stringify(state.requestSent, null, 2);
                } else {
                    requestData.textContent = '';
                }
                
                // Show communication log if available
                if (state.commLog) {
                    commLog.innerHTML = state.commLog;
                } else {
                    commLog.innerHTML = '';
                }
            } else {
                // Clear current response data
                currentResponseRaw = null;
                currentResponseParsed = null;
                currentResponseError = null;
                
                responseViewer.innerHTML = '<span class="json-null">No response yet.</span>';
                requestData.textContent = '';
                commLog.innerHTML = '';
            }
        }
        
        // Reset request to default
        resetBtn.addEventListener('click', () => {
            if (!currentFlow || !currentMethod) return;
            
            const defaultRequest = flows[currentFlow].methods[currentMethod].defaultRequest;
            jsonEditor.value = JSON.stringify(defaultRequest, null, 4);
            
            // Update the next request ID
            if (defaultRequest.id) {
                defaultRequest.id = requestId++;
                jsonEditor.value = JSON.stringify(defaultRequest, null, 4);
            }
        });
        
        // Clear communication log
        clearLogBtn.addEventListener('click', () => {
            commLog.innerHTML = '';
            
            // Clear the log in the current method state
            if (currentFlow && currentMethod) {
                const key = `${currentFlow}:${currentMethod}`;
                if (methodState.has(key)) {
                    methodState.get(key).commLog = '';
                }
            }
        });
        
        // Connect to WebSocket server
        connectBtn.addEventListener('click', () => {
            const url = serverUrlInput.value.trim();
            
            if (!url) {
                alert('Please enter a WebSocket server URL');
                return;
            }
            
            try {
                socket = new WebSocket(url);
                
                socket.onopen = () => {
                    isConnected = true;
                    statusSpan.textContent = 'Connected';
                    statusSpan.classList.remove('disconnected');
                    statusSpan.classList.add('connected');
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                    sendBtn.disabled = false;
                };
                
                socket.onclose = (event) => {
                    isConnected = false;
                    statusSpan.textContent = 'Disconnected';
                    statusSpan.classList.remove('connected');
                    statusSpan.classList.add('disconnected');
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                    sendBtn.disabled = true;
                };
                
                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
                
                socket.onmessage = (event) => {
                    // Store raw response
                    currentResponseRaw = event.data;
                    currentResponseParsed = null;
                    currentResponseError = null;
                    
                    try {
                        // Calculate response time
                        const responseTimestamp = new Date();
                        const responseTimeStr = responseTimestamp.toLocaleTimeString() + '.' + 
                                               String(responseTimestamp.getMilliseconds()).padStart(3, '0');
                        
                        // Calculate response size
                        const responseSize = new Blob([event.data]).size;
                        
                        const response = JSON.parse(event.data);
                        currentResponseParsed = response;
                        
                        // Special handling for responses that contain schemas
                        
                        // Handle tools/list response
                        if (currentMethod === 'tools/list' && response.result && response.result.tools) {
                            // Clear existing schemas
                            toolSchemas.clear();
                            
                            // Store each tool's schema
                            response.result.tools.forEach(tool => {
                                toolSchemas.set(tool.name, tool);
                            });
                            
                            // Update current tab if needed
                            if (currentActiveTab === 'editRequest') {
                                updateSchemaForm();
                            } else if (currentActiveTab === 'schema') {
                                updateSchemaView();
                            }
                        }
                        
                        // Handle initialize response - it might contain available methods
                        if (currentMethod === 'initialize' && response.result) {
                            // Store method capabilities if provided
                            if (response.result.capabilities) {
                                // Store for future use
                                const key = `${currentFlow}:${currentMethod}`;
                                if (!methodState.has(key)) {
                                    methodState.set(key, {});
                                }
                                methodState.get(key).capabilities = response.result.capabilities;
                            }
                        }
                        
                        // Display the response based on current toggle state
                        displayResponse();
                        
                        // Update communication log
                        let logEntry = '';
                        if (requestTimestamp) {
                            const elapsed = responseTimestamp - requestTimestamp;
                            logEntry = `[${responseTimeStr}] received response (${responseSize} bytes), latency ${elapsed}ms\n`;
                            commLog.innerHTML += logEntry;
                            
                            // Auto-scroll the log to the bottom
                            commLog.scrollTop = commLog.scrollHeight;
                        }
                        
                        // Save the response and log for the current method
                        if (currentFlow && currentMethod) {
                            const key = `${currentFlow}:${currentMethod}`;
                            
                            if (!methodState.has(key)) {
                                methodState.set(key, {});
                            }
                            
                            methodState.get(key).response = response;
                            methodState.get(key).responseRaw = event.data;
                            methodState.get(key).responseTimestamp = responseTimestamp;
                            methodState.get(key).commLog = commLog.innerHTML;
                            
                            // Add to history
                            const method = methodState.get(key).method || currentMethod;
                            const requestSent = methodState.get(key).requestSent;
                            if (requestSent) {
                                addToHistory(method, requestSent, response, event.data, null);
                            }
                            
                            // Check for special responses that need dynamic processing
                            if (currentFlow && currentMethod) {
                                // Define which responses we should process dynamically
                                const dynamicResponseHandlers = {
                                    'tools-flow': {
                                        'tools/list': {
                                            property: 'tools',
                                            processor: processDynamicList
                                        }
                                    },
                                    'resources-flow': {
                                        'resources/list': {
                                            property: 'resources',
                                            processor: processDynamicList
                                        }
                                    },
                                    'prompts-flow': {
                                        'prompts/list': {
                                            property: 'prompts',
                                            processor: processDynamicList
                                        }
                                    }
                                };
                                
                                // Check if we have a handler for this flow and method
                                if (dynamicResponseHandlers[currentFlow] && 
                                    dynamicResponseHandlers[currentFlow][currentMethod]) {
                                    
                                    const handler = dynamicResponseHandlers[currentFlow][currentMethod];
                                    const items = response.result && response.result[handler.property];
                                    
                                    if (items) {
                                        handler.processor(currentFlow, items);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        // If parse fails, store the error
                        currentResponseError = error.message;
                        console.error('Error parsing JSON response:', error);
                        
                        // Display based on current toggle state
                        displayResponse();
                        
                        // Save the error state for the current method
                        if (currentFlow && currentMethod) {
                            const key = `${currentFlow}:${currentMethod}`;
                            
                            if (!methodState.has(key)) {
                                methodState.set(key, {});
                            }
                            
                            methodState.get(key).responseRaw = event.data;
                            methodState.get(key).responseError = error.message;
                            methodState.get(key).commLog = commLog.innerHTML;
                            
                            // Add to history with error
                            const method = methodState.get(key).method || currentMethod;
                            const requestSent = methodState.get(key).requestSent;
                            if (requestSent) {
                                addToHistory(method, requestSent, null, event.data, error.message);
                            }
                        }
                    }
                };
                
            } catch (error) {
                alert(`Failed to connect: ${error.message}`);
                console.error('Connection error:', error);
            }
        });
        
        // Disconnect from WebSocket server
        disconnectBtn.addEventListener('click', () => {
            if (socket) {
                socket.close(1000, 'User initiated disconnect');
                socket = null;
            }
        });
        
        // Send request
        sendBtn.addEventListener('click', () => {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                alert('Not connected to the WebSocket server');
                return;
            }
            
            try {
                const requestJson = jsonEditor.value.trim();
                const requestObj = JSON.parse(requestJson);
                
                // Add an ID if not present and it's not a notification
                if (requestObj.method && requestObj.method !== 'notification' && !requestObj.id) {
                    requestObj.id = requestId++;
                    jsonEditor.value = JSON.stringify(requestObj, null, 4);
                }
                
                // Ensure jsonrpc version is set
                if (!requestObj.jsonrpc) {
                    requestObj.jsonrpc = '2.0';
                    jsonEditor.value = JSON.stringify(requestObj, null, 4);
                }
                
                const request = JSON.stringify(requestObj);
                const requestSize = new Blob([request]).size;
                
                // Record request timestamp
                requestTimestamp = new Date();
                const requestTimeStr = requestTimestamp.toLocaleTimeString() + '.' + 
                                       String(requestTimestamp.getMilliseconds()).padStart(3, '0');
                
                // Add to the communication log
                const logEntry = `[${requestTimeStr}] sending request (${requestSize} bytes)\n`;
                commLog.innerHTML += logEntry;
                
                // Auto-scroll the log to the bottom
                commLog.scrollTop = commLog.scrollHeight;
                
                // Send the request
                socket.send(request);
                
                // Update request display
                requestData.textContent = 'Request: ' + request;
                
                // Save the sent request and timestamp
                if (currentFlow && currentMethod) {
                    const key = `${currentFlow}:${currentMethod}`;
                    
                    if (!methodState.has(key)) {
                        methodState.set(key, {});
                    }
                    
                    methodState.get(key).requestSent = requestObj;
                    methodState.get(key).requestTimestamp = requestTimestamp;
                    methodState.get(key).commLog = commLog.innerHTML;
                    methodState.get(key).method = requestObj.method; // Store method for history
                }
                
            } catch (error) {
                alert(`Error sending request: ${error.message}`);
                console.error('Send error:', error);
            }
        });
        
        // Configuration for dynamic item processing
        const dynamicItemConfig = {
            'tools-flow': {
                itemPrefix: 'tool:',
                displayProperty: 'name',
                requiredProperty: 'name',
                removePredicate: (methodId) => !(methodId === 'tools/list' || methodId === 'tools/call'),
                createDefaultRequest: (item) => ({
                    jsonrpc: '2.0',
                    method: 'tools/call',
                    params: {
                        name: item.name,
                        arguments: createDefaultInputFromSchema(item.inputSchema)
                    },
                    id: 1
                })
            },
            'resources-flow': {
                itemPrefix: 'resource:',
                displayProperty: (item) => item.uri.replace('nd://', '').split('?')[0],
                requiredProperty: 'uri',
                removePredicate: (methodId) => methodId.startsWith('resource:'),
                createDefaultRequest: (item) => ({
                    jsonrpc: '2.0',
                    method: 'resources/read',
                    params: {
                        uri: item.uri
                    },
                    id: 1
                })
            },
            'prompts-flow': {
                itemPrefix: 'prompt:',
                displayProperty: 'name',
                requiredProperty: 'name',
                removePredicate: (methodId) => methodId.startsWith('prompt:'),
                createDefaultRequest: (item) => ({
                    jsonrpc: '2.0',
                    method: 'prompts/get',
                    params: {
                        name: item.name
                    },
                    id: 1
                })
            }
        };
        
        // Unified function to process dynamic lists
        function processDynamicList(flowId, items) {
            console.log(`Processing ${flowId} list:`, items);
            
            // Get config for this flow
            const config = dynamicItemConfig[flowId];
            if (!config) return;
            
            // Remove existing dynamic methods
            removeExistingDynamicItems(flowId);
            
            // Add each item as a separate method
            items.forEach(item => {
                // Check if the item has the required property
                const requiredProp = typeof config.requiredProperty === 'function' 
                    ? config.requiredProperty(item) 
                    : item[config.requiredProperty];
                    
                if (requiredProp) {
                    addDynamicMethod(flowId, item);
                }
            });
            
            // Refresh the methods view
            loadMethodsForFlow(flowId);
            
            // Set the loaded flag for this type
            if (flowId === 'tools-flow') dynamicToolsLoaded = true;
            else if (flowId === 'resources-flow') dynamicResourcesLoaded = true;
            else if (flowId === 'prompts-flow') dynamicPromptsLoaded = true;
        }
        
        // Remove existing dynamic methods based on flow
        function removeExistingDynamicItems(flowId) {
            const flow = flows[flowId];
            const config = dynamicItemConfig[flowId];
            
            if (!flow || !config) return;
            
            // Keep only the fixed methods based on the predicate
            const fixedMethods = {};
            Object.keys(flow.methods).forEach(methodId => {
                if (!config.removePredicate(methodId)) {
                    fixedMethods[methodId] = flow.methods[methodId];
                }
            });
            
            // Replace with just the fixed methods
            flows[flowId].methods = fixedMethods;
        }
        
        // Add a dynamic method based on flow and item
        function addDynamicMethod(flowId, item) {
            const config = dynamicItemConfig[flowId];
            if (!config) return;
            
            // Get display name based on configuration
            const displayName = typeof config.displayProperty === 'function' 
                ? config.displayProperty(item) 
                : item[config.displayProperty];
                
            const methodId = `${config.itemPrefix}${displayName}`;
            
            // Create dynamic method entry
            flows[flowId].methods[methodId] = {
                name: displayName,
                description: item.description || `Execute the '${displayName}' ${flowId.replace('-flow', '')}`,
                dynamic: true, // Mark as dynamically created
                defaultRequest: config.createDefaultRequest(item),
                // Store the full tool data if it's a tool
                toolData: flowId === 'tools-flow' ? item : null
            };
            
            console.log(`Added dynamic method to ${flowId}: ${methodId}`, flows[flowId].methods[methodId]);
        }
        
        // Create default input values based on JSON schema
        function createDefaultInputFromSchema(schema) {
            // Default empty object
            const input = {};
            
            // If we have properties in the schema, populate with defaults
            if (schema && schema.properties) {
                const properties = schema.properties;
                
                Object.keys(properties).forEach(propName => {
                    // Try to create sensible defaults based on property type
                    const property = properties[propName];
                    const type = property.type;
                    
                    if (type === 'string') {
                        // If there's an example, use it
                        if (property.examples && property.examples.length > 0) {
                            input[propName] = property.examples[0];
                        } 
                        // If there's a format, create a placeholder for it
                        else if (property.format) {
                            switch (property.format) {
                                case 'date-time':
                                    input[propName] = new Date().toISOString();
                                    break;
                                case 'date':
                                    input[propName] = new Date().toISOString().split('T')[0];
                                    break;
                                case 'time':
                                    input[propName] = new Date().toISOString().split('T')[1].split('.')[0];
                                    break;
                                case 'email':
                                    input[propName] = "user@example.com";
                                    break;
                                case 'hostname':
                                    input[propName] = "example.com";
                                    break;
                                case 'ipv4':
                                    input[propName] = "192.168.1.1";
                                    break;
                                case 'ipv6':
                                    input[propName] = "2001:db8::1";
                                    break;
                                case 'uri':
                                    input[propName] = "https://example.com";
                                    break;
                                default:
                                    input[propName] = "";
                            }
                        } 
                        // Otherwise use an empty string
                        else {
                            input[propName] = "";
                        }
                    } 
                    else if (type === 'number' || type === 'integer') {
                        // Use default if provided, otherwise 0
                        input[propName] = property.default !== undefined ? property.default : 0;
                    } 
                    else if (type === 'boolean') {
                        // Use default if provided, otherwise false
                        input[propName] = property.default !== undefined ? property.default : false;
                    } 
                    else if (type === 'array') {
                        // Use empty array
                        input[propName] = [];
                    } 
                    else if (type === 'object') {
                        // Use empty object
                        input[propName] = {};
                    } 
                    else {
                        // For any other type, just use null
                        input[propName] = null;
                    }
                });
            }
            
            return input;
        }
        
        // Load saved state from localStorage
        function loadSavedState() {
            const savedFlow = localStorage.getItem('selected-flow');
            if (savedFlow && flows[savedFlow]) {
                currentFlow = savedFlow;
            }
            
            // For each flow, load saved requests
            Object.keys(flows).forEach(flowId => {
                const flow = flows[flowId];
                Object.keys(flow.methods).forEach(methodId => {
                    const key = `${flowId}:${methodId}`;
                    const savedRequest = localStorage.getItem(`request:${key}`);
                    
                    if (savedRequest) {
                        try {
                            const requestObj = JSON.parse(savedRequest);
                            if (!methodState.has(key)) {
                                methodState.set(key, {});
                            }
                            methodState.get(key).request = requestObj;
                        } catch (error) {
                            console.error(`Failed to parse saved request for ${key}:`, error);
                        }
                    }
                });
            });
        }
        
        // Initialize the UI
        loadHistory();
        loadSavedState();
        initializeUI();
        
        // Update form when typing in raw editor (mainly for tools/call)
        jsonEditor.addEventListener('input', () => {
            if (currentActiveTab === 'editRequest' && currentMethod === 'tools/call') {
                // Debounce the update to avoid too many refreshes
                clearTimeout(jsonEditor.updateTimer);
                jsonEditor.updateTimer = setTimeout(() => {
                    updateSchemaForm();
                }, 500);
            }
        });
    </script>
</body>
</html>